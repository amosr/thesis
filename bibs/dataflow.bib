% -- A --

@article{amagbegnon1995implementation,
  title={Implementation of the data-flow synchronous language {S}ignal},
  author={Amagb{\'e}gnon, Pascalin and Besnard, Lo{\"\i}c and Le Guernic, Paul},
  journal={ACM SIGPLAN Notices},
  volume={30},
  number={6},
  pages={163--173},
  year={1995},
  publisher={ACM}
}

% -- B --

% Dataflow
% Synchrony is described as ``time advances in lockstep with one or more clocks''
% Formal definition of synchrony - somewhat hard to follow.
%
% - Lustre: declarative causal synchronous.
%
% - Esterel: imperative, nested, concurrent; each thread synchronised to a single global clock.
%     Threads communicate only through signals, but signals are not buffered or persistent:
%     after sending a signal, the value is kept for the next reaction but cleared after that.
%     Supports `preemptive statements' which allow presence of a signal to interrupt a loop.
%     Allegedly functional, but I don't see that.
%     Uses a causality analysis to rule out deadlocks.
%     These are very different to Kahn process networks, as messages disappear across iterations.
%
% - Signal: close to Lustre but multiclock.
%     Seems to have a better story than Lustre about checking clocks by abstracting them.
%     Allegedly,
%     ``Signal allows to mix reactive communication (offered by environment) and proactive communication (demanded by program)''
%     but there are no examples of this here.
%
% The actual `highlights of the last 12 years' are fairly boring, just commercial stuff, Lustre supporting arrays, new ways of compiling Esterel.
% Nothing new in terms of expressivity.
@article{benveniste2003synchronous,
  title={The synchronous languages 12 years later},
  author={Benveniste, Albert and Caspi, Paul and Edwards, Stephen A and Halbwachs, Nicolas and Le Guernic, Paul and De Simone, Robert},
  journal={Proceedings of the IEEE},
  volume={91},
  number={1},
  pages={64--83},
  year={2003},
  publisher={IEEE}
}

% Esterel generates automata. For programs where the automaton is too big, they can generate several smaller automata instead.
% Rough description of automata generation and generated sizes
@article{berry1992esterel,
  title={The {E}sterel synchronous programming language: Design, semantics, implementation},
  author={Berry, G{\'e}rard and Gonthier, Georges},
  journal={Science of computer programming},
  volume={19},
  number={2},
  pages={87--152},
  year={1992},
  publisher={Elsevier}
}

@article{berry1992hardware,
  title={A hardware implementation of pure {E}sterel},
  author={Berry, G{\'e}rard},
  journal={Sadhana},
  volume={17},
  number={1},
  pages={95--130},
  year={1992},
  publisher={Springer}
}

% Overview of Esterel and brief idea of optimisation
@inproceedings{berry2000foundations,
  title={The foundations of {E}sterel},
  author={Berry, G{\'e}rard},
  booktitle={Proof, language, and interaction},
  pages={425--454},
  year={2000}
}

% Parameterized
@article{bhattacharya2001parameterized,
  title={Parameterized dataflow modeling for {DSP} systems},
  author={Bhattacharya, Bishnupriya and Bhattacharyya, Shuvra S},
  journal={IEEE Transactions on Signal Processing},
  year={2001},
  publisher={IEEE}
}

% Scheduling is undecidable in general
% Boolean dataflow
% It's all about taking a graph that contains irregular/not-synchronous actors, and putting
% these irregular subgraphs into clusters so that, viewed externally, they are regular (1 in 1 out).
% So looking at an if implemented as something like
% (switch P; (T | F); select)
% the T and the F aren't regular, but the whole thing taken together forms a regular graph.
% But you're using a more expressive language - switches and selects and madness - when
% you really want to restrict these to only be used in structured ways.
@inproceedings{buck1993scheduling,
  title={Scheduling dynamic dataflow graphs with bounded memory using the token flow model},
  author={Buck, Joseph Tobin and Lee, Edward A},
  booktitle={Acoustics, Speech, and Signal Processing, 1993. ICASSP-93., 1993 IEEE International Conference on},
  volume={1},
  pages={429--432},
  year={1993},
  organization={IEEE}
}

% Integer dataflow
% Clustering to find control structure: tries to recover structures like ifs, cases and loops
% from the dataflow graph.
% Extends previous (buck1993scheduling) with loops that repeat some number of times, and multi-way ifs
% Very rigid and only supports limited control flow structures.
% Unclear how a merge or append would be clustered by this system.
@inproceedings{buck1994static,
  title={Static scheduling and code generation from dynamic dataflow graphs with integer-valued control streams},
  author={Buck, Joseph T},
  booktitle={Signals, Systems and Computers, 1994. 1994 Conference Record of the Twenty-Eighth Asilomar Conference on},
  volume={1},
  pages={508--513},
  year={1994},
  organization={IEEE}
}

% Good comparison of different kinds of dataflow networks.
% Boolean dataflow (BDF) extends SDF with some sort of control flow,
% and integer dataflow extends BDF with integers.
% Boundedness and liveness for BDF and IDF are undecidable, but
% static analysis can be done for many `practical problems'.
% Deals with dynamic scheduling, with some static schedules for particular cases
@phdthesis{bouakaz2013real,
  title={Real-time scheduling of dataflow graphs},
  author={Bouakaz, Adnan},
  year={2013},
  school={Universit{\'e} Rennes 1}
}


% -- C --

% Lucid Synchrone
@article{caspi1995functional,
  title={A functional extension to Lustre},
  author={Caspi, Paul and Pouzet, Marc},
  journal={Intensional Programming I},
  pages={15},
  year={1995},
  publisher={World Scientific}
}

% Example where listlessness diverges
@inproceedings{caspi1996synchronous,
  title={Synchronous {K}ahn networks},
  author={Caspi, Paul and Pouzet, Marc},
  booktitle={ACM SIGPLAN Notices},
  volume={31},
  pages={226--238},
  year={1996},
  organization={ACM}
}

% Rather than requiring clocks to be exactly equal / synchronous, allows clocks to be considered equivalent using a relaxed restriction: if a finite buffer or delay could be introduced to make them equivalent, they are equivalent.
@article{cohen2006n,
  title={N-synchronous {K}ahn networks: a relaxed model of synchrony for real-time systems},
  author={Cohen, Albert and Duranton, Marc and Eisenbeis, Christine and Pagetti, Claire and Plateau, Florence and Pouzet, Marc},
  journal={ACM SIGPLAN Notices},
  volume={41},
  number={1},
  pages={180--193},
  year={2006},
  publisher={ACM}
}


% -- D --

% -- E --

% Simple scheduling algorithm for concurrent Esterel programs, statically divides generated CFG into clusters of instructions that must be executed atomically.
% Each cluster is generated as a normal sequential block of instructions, then once it finishes it jumps to the next scheduled cluster, which is stored in a local linked list.
% Due to the limited concurrency in Esterel, each cluster can be executed 'concurrently' with only a restricted set of other clusters on the same 'level'.
% Each level has a separate linked list for its scheduled operations.
@article{edwards2006compiling,
  title={Compiling {E}sterel into static discrete-event code},
  author={Edwards, Stephen A and Kapadia, Vimal and Halas, Michael},
  journal={Electronic Notes in Theoretical Computer Science},
  volume={153},
  number={4},
  pages={117--131},
  year={2006},
  publisher={Elsevier}
}

% -- F --

@inproceedings{fradet2012spdf,
  title={{SPDF}: A schedulable parametric data-flow {MoC}},
  author={Fradet, Pascal and Girault, Alain and Poplavko, Peter},
  booktitle={Design, Automation \& Test in Europe Conference \& Exhibition (DATE), 2012},
  year={2012},
}

% -- G --

% -- H --

% Dataflow language: causal analysis, clock calculus, synchronous.
% Uses more or less syntactic equality to check equivalence of clocks.
@article{halbwachs1991synchronous,
  title={The synchronous data flow programming language {Lustre}},
  author={Halbwachs, Nicholas and Caspi, Paul and Raymond, Pascal and Pilaud, Daniel},
  journal={Proceedings of the IEEE},
  volume={79},
  number={9},
  pages={1305--1320},
  year={1991},
  publisher={IEEE}
}

% -- I --

% -- J --

@article{johnsonbaugh1982petri,
  title={Petri nets and marked graphs--mathematical models of concurrent computation},
  author={Johnsonbaugh, Richard and Murata, Tadao},
  journal={The American mathematical monthly},
  volume={89},
  number={8},
  pages={552--566},
  year={1982},
  publisher={Taylor \& Francis}
}

@article{johnston2004advances,
  title={Advances in dataflow programming languages},
  author={Johnston, Wesley M and Hanna, JR and Millar, Richard J},
  journal={ACM computing surveys (CSUR)},
  volume={36},
  number={1},
  pages={1--34},
  year={2004},
  publisher={ACM}
}


% -- K --

% -- L --

% SIGNAL synchronous dataflow language
% Polychrony: circuits/systems with many different clock rates.
% Allows local/internal oversampling, that are not observable from outside.
% Builds a hierarchical representation of clocks as a forest of trees,
% where x is placed under y iff x < y, ie x is a downsampling of y.
% In this case a merge would have
%   x < (merge x y)
% and
%   y < (merge x y)
% so it is not obvious whether this is supported.
%
% A simpler example for synchronous languages would be round-robin pulling from two inputs - not zipping, because that would enforce the same clock, but for round robin they could have clocks with the same period but a little delay between them.
% 
@article{le2003polychrony,
  title={Polychrony for system design},
  author={Le Guernic, Paul and Talpin, Jean-Pierre and Le Lann, Jean-Christophe},
  journal={Journal of Circuits, Systems, and Computers},
  volume={12},
  number={03},
  pages={261--303},
  year={2003},
  publisher={World Scientific}
}


% -- M --

% Synchronous dataflow does not allow value-dependent access patterns or appends or....
% Lucy extends this with a boolean clock calculus, but only allows periodic (repeating) clocks with a constant prefix - this cannot express append, merge or filter
@inproceedings{mandel2010lucy,
  title={Lucy-n: a n-synchronous extension of {Lustre}},
  author={Mandel, Louis and Plateau, Florence and Pouzet, Marc},
  booktitle={International Conference on Mathematics of Program Construction},
  pages={288--309},
  year={2010},
  organization={Springer}
}

% Flow-based programming is very similar, data-flow network style, but the execution model is multithreaded with runtime scheduling.
@book{morrison2010flow,
  title={{Flow-Based Programming}: A new approach to application development},
  author={Morrison, J Paul},
  year={2010},
  publisher={CreateSpace}
}



% -- N --

% -- O --

% -- P --

% Prelude synchronous language
% Very similar to Lucy-n but only *strictly* periodic clocks, ie only fires every n steps, rather than Lucy-n's repeating periods.
@article{pagetti2011multi,
  title={Multi-task implementation of multi-periodic synchronous programs},
  author={Pagetti, Claire and Forget, Julien and Boniol, Fr{\'e}d{\'e}ric and Cordovilla, Mikel and Lesens, David},
  journal={Discrete event dynamic systems},
  volume={21},
  number={3},
  pages={307--338},
  year={2011},
  publisher={Springer}
}


% -- Q --

% -- R --

% -- S --

% Falling back to dynamic scheduling
@inproceedings{soule2013dynamic,
  title={Dynamic expressivity with static optimization for streaming languages},
  author={Soul{\'e}, Robert and Gordon, Michael I and Amarasinghe, Saman and Grimm, Robert and Hirzel, Martin},
  booktitle={Proceedings of the 7th ACM international conference on Distributed event-based systems},
  pages={159--170},
  year={2013},
  organization={ACM}
}

% Lightweight actors for the JVM.
% Uses linear types to ensure that messages are not aliased between actors.
% Has a postprocessor called the `weaver' which operates over the java bytecode to
% remove the overhead of actually performing actors as separate threads.
% This is more like modifying the Java bytecode to store explicit continuations on the stack, and still uses runtime scheduling.
@TechReport{srinivasan2010kilim,
  author =	 {Srinivasan, Sriram},
  title = 	 {{Kilim: a server framework with lightweight actors,
         	   isolation types and zero-copy messaging}},
  year = 	 2010,
  month = 	 feb,
  url = 	 {http://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-769.pdf},
  institution =  {University of Cambridge, Computer Laboratory},
  number = 	 {UCAM-CL-TR-769}
}

% Scenario-aware dataflow (SADF)
% Somehow use a separate finite state machine, which can control the rates of dataflows.
% Apparently more expressive/succinct than boolean dataflow (BDF) but also easier to analyze.
% (No comparison to IDF)
% `General SADF' must fall back to runtime scheduling, but some FSM-SADF can be done statically.
% Most analyses are about worst-case, average case runtimes and stuff.
% In FSM-SADF, however, the currently executing scenario can only be switched in between iterations of the whole graph.
% So after the whole graph executes one scenario, the FSM is used to find the next scenario to execute.
% This means that the currently executing scenario cannot depend on values read during the current scenario - which rules out paritioning, for example, because the choice of whether to emit on the true or false branch cannot be made until after the value has been emitted.
% It is possible to indirectly encode this by storing the value to emit in a buffer, and deferring the emit until next scenario - however this loses locality benefits of fusion.
@inproceedings{stuijk2011scenario,
  title={Scenario-aware dataflow: Modeling, analysis and implementation of dynamic applications},
  author={Stuijk, Sander and Geilen, Marc and Theelen, Bart and Basten, Twan},
  booktitle={Embedded Computer Systems (SAMOS), 2011 International Conference on},
  pages={404--411},
  year={2011},
  organization={IEEE}
}

@article{stream2003stream,
  title={STREAM: The {S}tanford Stream Data Manager},
  author={STREAM Group and others},
  journal={IEEE Data Engineering Bulletin},
  year={2003}
}

% -- T --

% Regular/synchronous dataflow, ie statically known rates.
% Only allows limited splits and joins: round robin and duplication for splits, round robin and combination for joins. 
% Does not support fully general graphs - instead using combinators to introduce a (split/join) and a combinator for a feedback loop.
@inproceedings{thies2002streamit,
  title={{StreamIt}: A language for streaming applications},
  author={Thies, William and Karczmarek, Michal and Amarasinghe, Saman},
  booktitle={International Conference on Compiler Construction},
  pages={179--196},
  year={2002},
  organization={Springer}
}


% -- U --

% -- V --

% SADF / FSM-SADF
% The focus is more about analysing worst-case execution time in order to ensure real time deadlines can be met.
% Much easier and better explanation than stuijk2011scenario
@inproceedings{van2015scenario,
  title={A scenario-aware dataflow programming model},
  author={Van Kampenhout, Reinier and Stuijk, Sander and Goossens, Kees},
  booktitle={Digital System Design (DSD), 2015 Euromicro Conference on},
  pages={25--32},
  year={2015},
  organization={IEEE}
}


% -- W --

% -- X --

% -- Y --

% -- Z --


