% -- A --

@article{amagbegnon1995implementation,
  title={Implementation of the data-flow synchronous language signal},
  author={Amagb{\'e}gnon, Pascalin and Besnard, Lo{\"\i}c and Le Guernic, Paul},
  journal={ACM SIGPLAN Notices},
  volume={30},
  number={6},
  pages={163--173},
  year={1995},
  publisher={ACM}
}

% -- B --

% Dataflow
% Synchrony is described as ``time advances in lockstep with one or more clocks''
% Formal definition of synchrony - somewhat hard to follow.
%
% - Lustre: declarative causal synchronous.
%
% - Esterel: imperative, nested, concurrent; each thread synchronised to a single global clock.
%     Threads communicate only through signals, but signals are not buffered or persistent:
%     after sending a signal, the value is kept for the next reaction but cleared after that.
%     Supports `preemptive statements' which allow presence of a signal to interrupt a loop.
%     Allegedly functional, but I don't see that.
%     Uses a causality analysis to rule out deadlocks.
%     These are very different to Kahn process networks, as messages disappear across iterations.
%
% - Signal: close to Lustre but multiclock.
%     Seems to have a better story than Lustre about checking clocks by abstracting them.
%     Allegedly,
%     ``Signal allows to mix reactive communication (offered by environment) and proactive communication (demanded by program)''
%     but there are no examples of this here.
%
% The actual `highlights of the last 12 years' are fairly boring, just commercial stuff, Lustre supporting arrays, new ways of compiling Esterel.
% Nothing new in terms of expressivity.
@article{benveniste2003synchronous,
  title={The synchronous languages 12 years later},
  author={Benveniste, Albert and Caspi, Paul and Edwards, Stephen A and Halbwachs, Nicolas and Le Guernic, Paul and De Simone, Robert},
  journal={Proceedings of the IEEE},
  year={2003},
}

% Parameterized
@article{bhattacharya2001parameterized,
  title={Parameterized dataflow modeling for DSP systems},
  author={Bhattacharya, Bishnupriya and Bhattacharyya, Shuvra S},
  journal={IEEE Transactions on Signal Processing},
  year={2001},
  publisher={IEEE}
}

% Scheduling is undecidable in general
% Boolean dataflow
% It's all about taking a graph that contains irregular/not-synchronous actors, and putting
% these irregular subgraphs into clusters so that, viewed externally, they are regular (1 in 1 out).
% So looking at an if implemented as something like
% (switch P; (T | F); select)
% the T and the F aren't regular, but the whole thing taken together forms a regular graph.
% But you're using a more expressive language - switches and selects and madness - when
% you really want to restrict these to only be used in structured ways.
@inproceedings{buck1993scheduling,
  title={Scheduling dynamic dataflow graphs with bounded memory using the token flow model},
  author={Buck, Joseph Tobin and Lee, Edward A},
  booktitle={Acoustics, Speech, and Signal Processing, IEEE International Conference on},
  year={1993},
}

% Integer dataflow
% Clustering to find control structure: tries to recover structures like ifs, cases and loops
% from the dataflow graph.
% Extends previous (buck1993scheduling) with loops that repeat some number of times, and multi-way ifs
% Very rigid and only supports limited control flow structures.
% Unclear how a merge or append would be clustered by this system.
@inproceedings{buck1994static,
  title={Static scheduling and code generation from dynamic dataflow graphs with integer-valued control streams},
  author={Buck, Joseph T},
  booktitle={Signals, Systems and Computers, Twenty-Eighth Asilomar Conference on},
  year={1994},
}

% Good comparison of different kinds of dataflow networks.
% Boolean dataflow (BDF) extends SDF with some sort of control flow,
% and integer dataflow extends BDF with integers.
% Boundedness and liveness for BDF and IDF are undecidable, but
% static analysis can be done for many `practical problems'.
% Deals with dynamic scheduling, with some static schedules for particular cases
@phdthesis{bouakaz2013real,
  title={Real-time scheduling of dataflow graphs},
  author={Bouakaz, Adnan},
  year={2013},
  school={Universit{\'e} Rennes 1}
}


% -- C --

% Example where listlessness diverges
@inproceedings{caspi1996synchronous,
  title={Synchronous kahn networks},
  author={Caspi, Paul and Pouzet, Marc},
  booktitle={ACM SIGPLAN Notices},
  volume={31},
  number={6},
  pages={226--238},
  year={1996},
  organization={ACM}
}

% Rather than requiring clocks to be exactly equal / syncrhonous, allows clocks to be considered equivalent using a relaxed restriction: if a finite buffer or delay could be introduced to make them equivalent, they are equivalent.
@article{cohen2006n,
  title={N-synchronous Kahn networks: a relaxed model of synchrony for real-time systems},
  author={Cohen, Albert and Duranton, Marc and Eisenbeis, Christine and Pagetti, Claire and Plateau, Florence and Pouzet, Marc},
  journal={ACM SIGPLAN Notices},
  volume={41},
  number={1},
  pages={180--193},
  year={2006},
  publisher={ACM}
}


% -- D --

% -- E --

% -- F --

@inproceedings{fradet2012spdf,
  title={SPDF: A schedulable parametric data-flow MoC},
  author={Fradet, Pascal and Girault, Alain and Poplavko, Peter},
  booktitle={Design, Automation \& Test in Europe Conference \& Exhibition (DATE), 2012},
  year={2012},
}

% -- G --

% -- H --

% Dataflow language: causal analysis, clock calculus, synchronous.
% Uses more or less syntactic equality to check equivalence of clocks.
@article{halbwachs1991synchronous,
  title={The synchronous data flow programming language LUSTRE},
  author={Halbwachs, Nicholas and Caspi, Paul and Raymond, Pascal and Pilaud, Daniel},
  journal={Proceedings of the IEEE},
  year={1991},
}


% -- I --

% -- J --

@article{johnston2004advances,
  title={Advances in dataflow programming languages},
  author={Johnston, Wesley M and Hanna, JR and Millar, Richard J},
  journal={ACM Computing Surveys (CSUR)},
  year={2004},
  publisher={ACM}
}


% -- K --

% -- L --

% SIGNAL synchronous dataflow language
% Polychrony: circuits/systems with many different clock rates.
% Allows local/internal oversampling, that are not observable from outside.
% Builds a hierarchical representation of clocks as a forest of trees,
% where x is placed under y iff x < y, ie x is a downsampling of y.
% In this case a merge would have
%   x < (merge x y)
% and
%   y < (merge x y)
% so it is not obvious whether this is supported.
%
% A simpler example for synchronous languages would be round-robin pulling from two inputs - not zipping, because that would enforce the same clock, but for round robin they could have clocks with the same period but a little delay between them.
% 
@article{le2003polychrony,
  title={Polychrony for system design},
  author={Le Guernic, Paul and Talpin, Jean-Pierre and Le Lann, Jean-Christophe},
  journal={Journal of Circuits, Systems, and Computers},
  year={2003},
}


% -- M --

% Synchronous dataflow does not allow value-dependent access patterns or appends or....
% Lucy extends this with a boolean clock calculus, but only allows periodic (repeating) clocks with a constant prefix - this cannot express append, merge or filter
@inproceedings{mandel2010lucy,
  title={Lucy-n: a n-synchronous extension of Lustre},
  author={Mandel, Louis and Plateau, Florence and Pouzet, Marc},
  booktitle={Mathematics of Program Construction},
  year={2010},
}


% -- N --

% -- O --

% -- P --

% Prelude synchronous language
% Very similar to Lucy-n but only *strictly* periodic clocks, ie only fires every n steps, rather than Lucy-n's repeating periods.
@article{pagetti2011multi,
  title={Multi-task implementation of multi-periodic synchronous programs},
  author={Pagetti, Claire and Forget, Julien and Boniol, Fr{\'e}d{\'e}ric and Cordovilla, Mikel and Lesens, David},
  journal={Discrete event dynamic systems},
  volume={21},
  number={3},
  pages={307--338},
  year={2011},
  publisher={Springer}
}


% -- Q --

% -- R --

% -- S --

% Falling back to dynamic scheduling
@InProceedings{soule2013dynamic,
  title     = "Dynamic Expressivity with Static Optimization for Streaming Languages",
  author    = "Robert Soule and Michael I. Gordon and Saman Amarasinghe and Robert Grimm and Martin Hirzel",
  booktitle = "The 7th ACM International Conference on Distributed Event-Based Systems",
  year      = "2013",
}

% Scenario-aware dataflow (SADF)
% Somehow use a separate finite state machine, which can control the rates of dataflows.
% Apparently more expressive/succinct than boolean dataflow (BDF) but also easier to analyze.
% (No comparison to IDF)
% `General SADF' must fall back to runtime scheduling, but some FSM-SADF can be done statically.
% Most analyses are about worst-case, average case runtimes and stuff.
% In FSM-SADF, however, the currently executing scenario can only be switched in between iterations of the whole graph.
% So after the whole graph executes one scenario, the FSM is used to find the next scenario to execute.
% This means that the currently executing scenario cannot depend on values read during the current scenario - which rules out paritioning, for example, because the choice of whether to emit on the true or false branch cannot be made until after the value has been emitted.
% It is possible to indirectly encode this by storing the value to emit in a buffer, and deferring the emit until next scenario - however this loses locality benefits of fusion.
@inproceedings{stuijk2011scenario,
  title={Scenario-aware dataflow: Modeling, analysis and implementation of dynamic applications},
  author={Stuijk, Sander and Geilen, Marc and Theelen, Bart and Basten, Twan},
  booktitle={Embedded Computer Systems (SAMOS), International Conference on},
  year={2011},
}

@article{stream2003stream,
  title={STREAM: The {S}tanford Stream Data Manager},
  author={STREAM Group and others},
  journal={IEEE Data Engineering Bulletin},
  year={2003}
}

% -- T --

% Regular/synchronous dataflow, ie statically known rates.
% Only allows limited splits and joins: round robin and duplication for splits, round robin and combination for joins. 
% Does not support fully general graphs - instead using combinators to introduce a (split/join) and a combinator for a feedback loop.
@inproceedings{thies2002streamit,
  title={StreamIt: A language for streaming applications},
  author={Thies, William and Karczmarek, Michal and Amarasinghe, Saman},
  booktitle={Compiler Construction},
  year={2002},
}


% -- U --

% -- V --

% SADF / FSM-SADF
% The focus is more about analysing worst-case execution time in order to ensure real time deadlines can be met.
% Much easier and better explanation than stuijk2011scenario
@inproceedings{van2015scenario,
  title={A scenario-aware dataflow programming model},
  author={Van Kampenhout, Reinier and Stuijk, Sander and Goossens, Kees},
  booktitle={Digital System Design (DSD), Euromicro Conference on},
  year={2015},
}


% -- W --

% -- X --

% -- Y --

% -- Z --


