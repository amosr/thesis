
% Meta-Repa similar idea but for flat data parallel computations, not really for streaming computations
@inproceedings{ankner2013edsl,
  title={An EDSL approach to high performance Haskell programming},
  author={Ankner, Johan and Svenningsson, Josef David},
  booktitle={ACM SIGPLAN Notices},
  volume={48},
  number={12},
  pages={1--12},
  year={2013},
  organization={ACM}
}

% Original, untyped Template Haskell
@inproceedings{sheard2002template,
  title={Template meta-programming for Haskell},
  author={Sheard, Tim and Jones, Simon Peyton},
  booktitle={Proceedings of the 2002 ACM SIGPLAN workshop on Haskell},
  pages={1--16},
  year={2002},
  organization={ACM}
}

% Quasiquoting and antiquoting for arbitrary DSLs.
% One of the big things is it works for patterns as well as expressions.
% Generic SYB to allow reuse of the same parser.
% Not particularly relevant here.
@inproceedings{mainland2007s,
  title={Why it's nice to be quoted: quasiquoting for haskell},
  author={Mainland, Geoffrey},
  booktitle={Proceedings of the ACM SIGPLAN workshop on Haskell workshop},
  pages={73--82},
  year={2007},
  organization={ACM}
}

% Type-based rather than syntactic staging.
% Makes the point that keeping the representation abstract is important for safety, as equivalent
% programs should not be distinguishable. See [taha1999sound].
% But then the optimisations are able to perform structural rewrites, so they aren't using an abstract representation?
% "Safety is maintained by exposing the internal code structure only to rewriting modules but keeping it hidden from the client generator code"
% I don't understand how that maintains safety, it seems to just move the inherent unsafety from one place to another. I suppose you have to explicitly opt-in to the unsafe parts.
% I guess you can still reason about higher-order code as you would about higher-order functions, because the only place you can take apart and inspect code is in the compilation/run stage.
@inproceedings{rompf2010lightweight,
  title={Lightweight modular staging: a pragmatic approach to runtime code generation and compiled DSLs},
  author={Rompf, Tiark and Odersky, Martin},
  booktitle={Acm Sigplan Notices},
  volume={46},
  number={2},
  pages={127--136},
  year={2010},
  organization={ACM}
}

% "Part of the strength of the equational properties of MetaML comes from the absence of a mechanism for intensional analysis"
% "adding intensional analysis ... weakens the notion of equivalence to the extent that it makes most interesting program optimisations unsound"
% I suppose it is saying that allowing the programmer to observe the difference between "expression e" and "let x = expression in x", these sort of optimisations cannot be applied because they change the meaning. But wouldn't you still be able to apply them, only before 'run'?
% But it is hard to limit things like beta-reduction to level-0 because you want substitution to act uniformly over different stages, and anyway it is hard to tell the level of an expression by the expression alone - it depends on the context.
% "We are forced to allow beta-reduction to leak into higher levels, and we see this leakage as beneficial as it allows implementations to perform a wider range of semantics-preserving optimisations"
@article{taha1999sound,
  title={A sound reduction semantics for untyped CBN multi-stage computation. Or, the theory of MetaML is non-trival},
  author={Taha, Walid},
  journal={ACM SIGPLAN Notices},
  volume={34},
  number={11},
  pages={34--43},
  year={1999},
  publisher={ACM}
}
