\chapter{Introduction}

Today, the ATM swallowed my card and put my balance in arrears.
Or perhaps yesterday, I don't remember.
I must have done something wrong.
Machines don't just take people's money for no reason. 
I must have chosen the wrong option.
Perhaps it was yesterday.

For me, it is hard to imagine spending a day without interacting with software in some way.
Most of the software I touch is fairly innocuous, where an error might cause a few minutes' grumbling, but no real heartache.
For other software, such as the banking server at my building society, or the cruise control on my car, errors can be disastrous.
Unfortunately, the level of \emph{trust} provided to software does not generally coincide with the level of \emph{effort} to ensure correctness of that software.
When banking software goes awry, people suffer financially.
When debt recovery software goes awry, people suffer emotionally.
When car software goes awry, people suffer physically.
It is hard to imagine spending a day without software going awry in some way.

What really makes this topic frustrating is that these are, in some sense, solved problems.
We know how to write correct software, or at least we know how to write \emph{more} correct software.
With formal methods we can prove that a program acts in accordance with some high-level specification.
With type systems we can rule out whole classes of bugs and vulnerabilities just by compiling and typechecking the program.
With high-level languages and high-level abstractions we can write programs that are more ``obviously correct'' and easier to reason about.

So why do these problems persist?
Part of this is the effort required: there is a non-trivial cost to proving programs correct using formal methods.
Another part is certainly a lack of education and inertia.
However, the part I wish to focus on is the performance costs associated with high-level abstractions.

Compared to traditional imperative languages such as C, Java or Go, high-level languages with static type systems (Haskell being a notable example) reach a sweet middle ground in terms of effort to correctness.
While they do not ensure the complete correctness that formal methods promise, they still provide valuable guarantees about the absence of particular errors.

The goal of this thesis is to explore and ameliorate the performance issues with a particular set of programs: streaming combinator programs.

\section{Streaming combinators}

Streaming combinator programs are 

