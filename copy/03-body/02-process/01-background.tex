\chapter{Background}
\label{chapter:process:background}

Some introduction is required before delving into the details of \emph{process fusion}.
Fusion is first and foremost an optimisation for making programs run faster - but there are two main parts to this.
Firstly, by fusing two loops together, the loop overhead that was previously paid twice is now only paid once.
That is, the second set of looping instructions are removed from the program.
This has some benefit, but generally only in cases where the loops are small: if the loops were performing more than a few instructions, its cost would outweigh the negligible amount of loop overhead.

The real benefit of fusion comes from the fact that the fused program now has different space and time locality: by moving the instructions that write to an array next to instructions that read that same value, the value is more likely to be held in a register or in cache, saving a potentially expensive memory lookup.
The intermediate array can also be removed from memory, but this is more of a side-benefit than anything else.
In imperative languages, removing intermediate arrays is performed as a separate step called array contraction.

While it is possible to perform fusion.

The issue of cache locality.

Streaming applications, where the input size is larger than fits in main memory, are very important.

\section{Kahn process networks}

\FigurePdf{figs/combinators/nd-merge}{Non-deterministic merge with values flowing through}{Non-deterministic merge: upper values (blue) and lower values (red) are passed through. Unlike normal streaming operations, the time domain is explicit in the streams.}

\section{Bounded and unbounded buffers}

\begin{code}
pairEvenOdd :: Array Int -> Array (Int, Int)
pairEvenOdd input
 = let evens = filter even input
       odds  = filter odd  input
       pairs = zip evens odds
   in  pairs
\end{code}

\FigurePdf{figs/combinators/filter-even-odd}{Pairing even/odd: combinator diagram}{Combinator diagram for pairing even/odd.}


\section{Stream polarity}

The most important thing for streaming computations is to be able to stream in constant memory - there is little point writing a streaming computation if 

There are two main ways of 

\FigurePdf{figs/polarity/mappairs}{Map pairs: polarity diagram}{Polarity diagram for map pairs. Filled circles denote pull streams, as they always have an element inside that can be pulled. Empty circles denote push streams, as there is an empty hole that can always be filled by pushing to.}

\FigurePdf{figs/polarity/mappairs-cycle}{Map pairs: cycle diagram}{Polarity diagram for map pairs with the edges for push streams flipped, and the resulting graph cycle highlighted in red.}


\citet{kay2009you} 


\FigurePdf{figs/polarity/zipples}{Zipping pairs together: polarity diagram}{Polarity diagram for a contrived zip example.}

\FigurePdf{figs/polarity/zipples-cycle}{Zipping pairs together: cycle diagram}{Polarity diagram for contrived zip example with the edges for push streams flipped, and the resulting graph cycle highlighted in red.}

\subsection{Pull streams}

\begin{code}
data Pull a
 = Pull 
 { pull :: IO (Maybe a) }

pullOfList :: [a] -> Pull a
pullOfList xs0
 = do xsR <- newIORef xs0
      return Pull
       { pull = do
        xs <- readIORef xsR
        case xs of
         []      -> return Nothing
         (x:xs') -> writeIORef xsR xs' >> return Nothing
       }
\end{code}

\subsection{Push streams}
\begin{code}
data Push a = Push
 { push :: a -> IO ()
 , done :: IO () }

pushOfList :: [a] -> Push a -> IO ()
pushOfList xs0 p
 = case xs0 of
    [] -> done p
    (x:xs') -> push p x >> pushOfList
\end{code}

\subsection{Control streams}
\begin{code}
data Control a
 = ...
\end{code}


\section{Online and offline}

\section{Comparison}

\begin{table}
\begin{center}
\begin{tabular}{|l||c|c|c|c|c|}
\hline
 & Split & Join & Diamond & Extensible & Nondeterministic merge \\
\hline
\hline
Polarized data flow
  & $\checkmark$ & $\checkmark$ & $\times$ & $\checkmark$ & $\checkmark$ \\
Pull
  & $\times$ & $\checkmark$ & $\times$ & $\checkmark$ & $\times$ \\
Push
  & $\checkmark$ & $\times$ & $\times$ & $\checkmark$ & $\checkmark$ \\
Data flow
  & $\checkmark$ & $\checkmark$ & $\checkmark$ & $\times$ & $\times$ \\
Machine/process
  & $\checkmark$ & $\checkmark$ & $\checkmark$ & $\checkmark$ & $\times$ \\
\hline
\end{tabular}
\end{center}
\caption[Comparison between fusion systems]{Comparison of different fusion systems according to graph criteria (splits, joins and diamonds) as well as whether new combinators can be added without modifying the underlying fusion algorithm (extensible).}
\label{03-body/02-process/01-background/comparison/table}
\end{table}

\autoref{03-body/02-process/01-background/comparison/table} shows the comparison between polarized data flow fusion (PDFF), pull fusion systems such as stream fusion (Pull), push fusion systems (Push), data flow fusion (DFF) and the process fusion system presented here (MPF).

