\chapter{Processes and networks}
\label{chapter:process:processes}

This chapter presents a language for expressing a collection of queries, each with potentially many input streams, as a Kahn process network.
This work was first published as \citet{robinson2017machine}.
The processes in these process networks execute concurrently and communicate via fixed-size bounded buffers between channels.
Each buffer is restricted to contain at most a single element.
The processes in a process network are then fused together to form a single process which produces the same output streams as the entire network, without the need for inter-process communication.

The contributions of this chapter are:
\begin{itemize}
\item
We informally introduce processes and fusion with example queries (\cref{kpn/gold-panning});
\item
We present a streaming process calculus with concurrent execution semantics (\cref{kpn/process-definition});
\item
We present an algorithm for fusing pairs of processes (\cref{s:Fusion});
\item
We motivate an extra synchronisation primitive, \lstiproc@drop@, which coordinates between multiple consumers of the same stream, to improve locality by ensuring both consumers operate on the same value concurrently
(\cref{s:Drop:in:synchrony});
\item
We present a heuristic algorithm for fusing an entire process network (\cref{s:Optimisation});
\item
We present an overview of the mechanised soundness proofs of fusion (\cref{s:Proofs}).
\end{itemize}



\section{Gold panning with processes}
\label{kpn/gold-panning}
Recall the \lstiproc@priceAnalyses@ example from \cref{taxonomy/gold-panning}, which performs statistical analyses over the daily prices of a particular corporate stock and market index.
\Cref{figs/procs/priceAnalyses-again} shows the dependency graph for \lstiproc@priceAnalyses@ with the two input streams, \lstiproc@index@ and \lstiproc@stock@, at the top of the graph.

\FigurePdfLabel{figs/depgraphs/priceOverTime-priceOverMarket}{figs/procs/priceAnalyses-again}{Dependency graph for \Hs/priceAnalyses/ example}

As discussed earlier, we cannot execute this example in a single pass using the pull streams from \cref{taxonomy/pull}, because the \lstiproc@stock@ input stream is used twice, and pull streams only support a single consumer.
Similarly, we cannot execute this example in a single pass using the push streams from \cref{taxonomy/push}, because the \lstiproc@join@ combinator has two inputs, and push streams only support a single producer except for non-deterministic merge.
Rather than just using pull streams, or just using push streams, we wish to be able to perform both pulling and pushing in the same computation, in a way that supports multiple consumers and multiple producers.
Kahn process networks \citep{kahn1976coroutines} are a flexible, expressive way of writing streaming computations, where a network is composed of communicating processes.
Executing communicating processes introduces runtime overhead, as stream elements must be passed between processes.
Instead, we wish to take this concurrent process network and convert it to sequential code that does not need any runtime scheduling or message passing overhead.

% This additional communication means that a stream element which may have been in cache, has likely been swapped out by the time the consumer receives it.
% Or if the consumer is running on a different processor, it is unlikely to be in the lower level of cache in the first place.
% Furthermore, communication primitives likely require some kind of locking, which will add even more overhead.
%
% A lot of the time, the ideal execution model is actually just a simple imperative loop.
% By using concurrent processes we have gained expressivity, but at the cost of speed.

A \emph{process} in our system is a simple imperative program with a local heap.
A process pulls source values from an arbitrary number of input streams and pushes result values to at least one output stream.
The process language is an intermediate representation we use when fusing the overall dataflow network.
When describing the fusion transform we describe the control flow of the process as a state machine.

A \emph{combinator} is a template for a process which parameterises it over the particular input and output streams, as well as values of configuration parameters such as the worker function used in a \lstiproc@map@ process.
Each process implements a logical \emph{operator} --- so we use ``operator'' when describing the values being computed, but ``process'' when referring to the implementation.


\subsection{Fold combinator}
\begin{process}[float,caption=Process implementation of \Hs/foldl/,label=figs/procs/impl/foldl]
foldl 
  = \ (k  : b -> a -> b) (z   : b) (j : b -> c)
      (sIn: Stream a)    (sOut: Stream c). 
    / (s  : b) (v : a)   (F0..F4: Label).
    process
     { ins:    { sIn  }
     , outs:   { sOut }
     , heap:   { s = z, v }
     , label:    F0
     , instrs: { F0 = pull  sIn     v  F1[] else F2[]
               , F1 = drop  sIn        F0[s = k s v]

               -- sIn closed
               , F2 = push  sOut (j s) F3[]
               , F3 = close sOut       F4[]
               , F4 = exit } }
\end{process}

The definition of the \lstiproc@foldl@ combinator, used to implement \lstiproc@correlation@ and \lstiproc@regression@ in our \lstiproc@priceAnalyses@ process network, is given in \cref{figs/procs/impl/foldl}.
The combinator is parameterised by the fold state update function (\lstiproc@k@) and the fold state initialisation (\lstiproc@z@).
In \lstiproc@correlation@ and \lstiproc@regression@, the result must be extracted from the fold state; we extend the standard presentation of \lstiproc@foldl@ with an eject function (\lstiproc@j@) to perform this extraction.
The process reads from an input stream and, at the end of the input stream, produces a single-element output stream containing the fold result.
The \emph{nu-binders} ($\nu@ (s : a) (v : b)@\ldots$) indicate that each time the \lstiproc@foldl@ combinator is instantiated, fresh names must be given to \lstiproc@s@, \lstiproc@v@ and so on, that do not conflict with other insantiations.
The \lstiproc@s@ and \lstiproc@v@ bindings refer to variables in the mutable heap of the process.
The \lstiproc@s@ variable stores the current fold state and is initialised to the initial fold value (\lstiproc@z@); the \lstiproc@v@ variable stores the most recent value from the input stream, and is left uninitialised.

The body of the combinator is a record that defines the process.
The \lstiproc@ins@ field defines the set of input streams, and the \lstiproc@outs@ field defines the set of output streams.
The \lstiproc@heap@ field gives the initial values of each of the local variables; variables without an explicit initial value are given some arbitrary value.
The \lstiproc@instrs@ field contains a set of labelled instructions that define the program, while the \lstiproc@label@ field gives the label of the initial instruction.
In this form, the output stream (\lstiproc@sOut@) is defined via a parameter, rather than being the result of the combinator.

The initial instruction (\lstiproc!pull sIn v F1[] else F2[]!) pulls the next element from the stream \lstiproc@sIn@, writes it into the heap variable \lstiproc@v@, then proceeds to the instruction at label \lstiproc@F1@.
The empty list \lstiproc@[]@ after the target label \lstiproc@F1@ can be used to update heap variables, but as we do not need to update anything yet we leave it empty. 
If the input stream is finished, there are no more elements to pull; execution proceeds to the instruction at label \lstiproc@F2@ instead.

After successfully pulling a new element from the input stream, the instruction at label \lstiproc@F1@ (\lstiproc!drop sIn F0[s = k s v]!) signals that the current element that was pulled from stream \lstiproc@sIn@ is no longer required, before updating the fold state (\lstiproc@s@) by applying the fold update function (\lstiproc@k@).
Execution then proceeds back to the pull instruction at label \lstiproc@F0@.
In \cref{s:Drop:in:synchrony} we shall see how this \lstiproc@drop@ instruction is used to synchronise processes reading from the same shared stream, ensuring that all processes operate on the same element together without overtaking one another.

When the input stream is finished, the instruction (\lstiproc!push sOut (j s) F3[]!) pushes the result of the eject function applied to the final fold state to the output stream \lstiproc@sOut@.
Execution then proceeds to the instruction at label \lstiproc@F3@.
The comment above the instruction highlights the change in state of the input stream.

Next, the instruction (\lstiproc!close sOut F4[]!) signals that the output stream \lstiproc@sOut@ is finished, and then proceeds to the instruction at label \lstiproc@F4@.

Finally, the instruction (\lstiproc!exit!) signals that the process is finished, and has no further work to do.
The process terminates.

\subsection{Map combinator}

\begin{process}[float,caption=Process implementation of \Hs/map/,label=figs/procs/impl/map]
map 
  = \ (f  : a -> b)
      (sIn: Stream a) (sOut: Stream b). 
    / (v  : a)        (M0..M4: Label).
    process
     { ins:    { sIn  }
     , outs:   { sOut }
     , heap:   { v }
     , label:  M0
     , instrs: { M0 = pull  sIn     v  M1[] else M3[]
               , M1 = push  sOut (f v) M2[]
               , M2 = drop  sIn        M0[]

               -- sIn closed
               , M3 = close sOut       M4[]
               , M4 = exit } }
\end{process}

The definition of the \lstiproc@map@ combinator, which applies a worker function to every element in the input stream, is given in \cref{figs/procs/impl/map}.
The combinator is parameterised by the worker function (\lstiproc@f@), and takes one input stream (\lstiproc@sIn@) and produces one output stream (\lstiproc@sOut@).
The heap variable (\lstiproc@v@) is used to store the last value read from the input stream.
The process starts by pulling from the input stream, storing the element in the heap variable (\lstiproc@v@).
It then pushes the transformed element (\lstiproc@f v@) into the output stream, drops the element from the input stream, and pulls again.
When the input stream finishes, the process closes the output stream and terminates.

\subsection{A network of processes}
The \lstiproc@map@ and \lstiproc@foldl@ combinators are sufficient to express the \lstiproc@priceOverTime@ example, which takes a single input stream and computes the correlation and regression.
Here is the list implementation of \lstiproc@priceOverTime@ again:

\begin{haskell}
priceOverTime :: [Record] -> (Line, Double)
priceOverTime stock =
  let timeprices = map (\r -> (daysSinceEpoch (time r), price r)) stock
  in (regression timeprices, correlation timeprices)
\end{haskell}

We can express \lstiproc@priceOverTime@ as a process network by instantiating the above process templates and connecting them together.
A process network is a set of processes that are able to communicate with each other.

\Cref{figs/procs/net/priceOverTime} shows the process network for \Hs/priceOverTime/.
As with the process templates, the network is parameterised by the output streams, which are in this case the output of \lstiproc@regression@ and \lstiproc@correlation@.
We use the nu-binder syntax to instantiate a fresh name for the \lstiproc@timeprices@ internal stream, which is the output of the \lstiproc@map@ combinator.
We implement \lstiproc@regression@ and \lstiproc@correlation@ as folds with eject functions.
The details of the worker functions given to \lstiproc@map@ and \lstiproc@foldl@ are defined externally.

\begin{process}[float,caption=Process network for \Hs/priceOverTime/,label=figs/procs/net/priceOverTime]
priceOverTime =
  \ (stock : Stream Record)
    (reg_out : Stream Line) (cor_out : Stream Double).
  / (timeprices : Stream (Double,Double)).
     { map    tp_f             stock      timeprices
     , foldl reg_k reg_z reg_j timeprices reg_out
     , foldl cor_k cor_z cor_j timeprices cor_out }
\end{process}


In \cref{part:icicle}, Icicle used the details of worker functions to perform common subexpression elimination after fusing queries together.
We could remove duplicate work from a process after performing fusion if we inlined the definitions of the worker functions into the process.
The processes here are more general than Icicle's intermediate language, as is necessary to support both multiple inputs and multiple queries; removing all duplicate work from processes may require a polynomial-time global value numbering algorithm \citep{gulwani2004polynomial} rather than the $O(n \log n)$ common subexpression elimination algorithm.
The fusion algorithm itself does not require the details of the worker functions, however, and we leave them externally defined for the present discussion.

\subsection{Fusing processes together}
\label{s:FusingProcesses}

Our fusion algorithm takes two processes and produces a new one that computes the output of both.
We fuse a pair of processes in the \lstiproc@priceOverTime@ network; to distinguish between the two \lstiproc@foldl@ processes in this network, we refer to them as the \lstiproc@regression@ and \lstiproc@correlation@ processes.
As an example, we fuse the \lstiproc@map@ process with the \lstiproc@regression@ process.
The result process computes the result of both processes as if they were executed concurrently, where the output stream of the \lstiproc@map@ process is used as the input stream of the \lstiproc@regression@ process.

\begin{figure}
\begin{process}
process -- map tp\_f stock timeprices
 { ins:    { stock  }
 , outs:   { timeprices }
 , heap:   { tp_v }
 , label:  M0
 , instrs: { M0 = pull  stock       tp_v        M1[] else M3[]
           , M1 = push  timeprices (tp_f tp_v)  M2[]
           , M2 = drop  stock                   M0[]

           -- stock closed
           , M3 = close timeprices              M4[]
           , M4 = exit } }
\end{process}
\vspace{1em}
\begin{dot2tex}[dot,scale=0.8]
digraph G {
node[shape=none,texmode="raw"];
  I[shape=point];
edge[style="procFstD,thick"];
  M0 [label="\CbF{pull stock tp\_v} (M0)"];
  M1 [label="\CbF{push timeprices (tp\_f tp\_v)} (M1)"];
  M2 [label="\CbF{drop stock} (M2)"];
  M3 [label="\CbF{close timeprices} (M3)"];
  M4 [label="\CbF{exit} (M4)"];

  I -> M0;

  M0 -> M1 [label="have stock "];
  M1 -> M2;
  M2 -> M0;

  M0 -> M3 [label="closed stock "];
  M3 -> M4;
}
\end{dot2tex}
\caption{Instantiated process for \Hs/map/ with control flow graph}
\label{figs/procs/instance/pot-timeprices}
\end{figure}

\begin{figure}
\begin{process}
process -- foldl reg\_k reg\_z reg\_j timeprices reg\_out
 { ins:    { timeprices  }
 , outs:   { reg_out }
 , heap:   { reg_s = reg_z, reg_v }
 , label:    F0
 , instrs: { F0 = pull  timeprices reg_v  F1[] else F2[]
           , F1 = drop  timeprices        F0[reg_s = reg_k reg_s reg_v]

           -- timeprices closed
           , F2 = push  reg_out (reg_j reg_s) F3[]
           , F3 = close reg_out       F4[]
           , F4 = exit } }
\end{process}
\vspace{1em}
\begin{dot2tex}[dot,scale=0.8]
digraph G {
node[shape=none];
  node[texmode="raw"];
edge[style="procSndD,thick"];
  I[shape=point];
  F0 [label="\CbS{pull timeprices reg\_v} (F0)"];
  F1 [label="\CbS{drop timeprices [reg\_s = reg\_k reg\_s reg\_v]} (F1)"];
  F2 [label="\CbS{push reg\_out (reg\_j reg\_s)} (F2)"];
  F3 [label="\CbS{close reg\_out} (F3)"];
  F4 [label="\CbS{exit} (F4)"];

  I -> F0;

  F0 -> F1 [label="have timeprices"];
  F1 -> F0;

  F0 -> F2 [label="closed timeprices"];
  F2 -> F3;
  F3 -> F4;
}
\end{dot2tex}
\caption{Instantiated process for \Hs/fold/ (\Hs/regression/) with control flow graph}
\label{figs/procs/instance/pot-regression}
\end{figure}

\Cref{figs/procs/instance/pot-timeprices} shows the result of instantiating the \lstiproc@map@ process in the \lstiproc@priceOverTime@ process network.
The combinator parameters have the corresponding argument value substituted in, and the variables and labels are given fresh names as necessary.
We rename the variable name \lstiproc@v@ to \lstiproc@tp_v@, to avoid conflict with variables named \lstiproc@v@ in other processes.
The figure also shows the control flow graph of the process.
\Cref{figs/procs/instance/pot-regression} likewise shows the result of instantiating the \lstiproc@regression@ process.
The instructions and edges in each control flow graph are coloured differently; the same colours will be used to highlight the provenance of each instruction in our informal description of the fusion algorithm.



\subsubsection{Fusing Pulls}
\label{s:Fusion:FusingPulls}

The algorithm proceeds by considering pairs of labels and instructions: one from each of the source processes to be fused.
First, we consider the initial labels of each process and their corresponding instructions.
This situation is shown in \cref{figs/fsm/fuse-pulls}; instructions from the two source processes are shown side-by-side and the instruction of the fused process is below.
The \lstiproc@map@ process pulls from the \lstiproc@stock@ stream, while the \lstiproc@regression@ process pulls from the \lstiproc@timeprices@ stream.
As the \lstiproc@timeprices@ stream is produced by the \lstiproc@map@ process, the \lstiproc@regression@ process must wait until the \lstiproc@map@ process pushes a value.
If we were to execute the two processes concurrently at this stage, only the \lstiproc@map@ process could make progress, by pulling from the \lstiproc@stock@ input stream.
The corresponding instruction for the fused process pulls from the \lstiproc@stock@ input stream, allowing the \lstiproc@map@ process to execute while the \lstiproc@regression@ process waits.


\begin{figure}
\center
\begin{tabular}{ll||rr}
\begin{dot2tex}[dot]
digraph G {
node[shape=none,texmode="raw"];
edge[style="procFstD,thick"];
  M0 [label="\CbF{pull stock tp\_v} (M0)"];
  M1 [label="... (M1)"];
  M3 [label="... (M3)"];
  M0 -> M1 [label="have stock"];
  M0 -> M3 [label="closed stock"];
}
\end{dot2tex}
& \quad & \quad &
\begin{dot2tex}[dot]
digraph G {
node[shape=none,texmode="raw"];
edge[style="procSndD,thick"];
  F0 [label="\CbS{pull timeprices reg\_v} (F0)"];
  F1 [label="... (F1)"];
  F2 [label="... (F2)"];
  F0 -> F1 [label="have timeprices"];
  F0 -> F2 [label="closed timeprices"];
}
\end{dot2tex}
\end{tabular}
\vspace{1em}
\center
\begin{dot2tex}[dot]
digraph G {
node[shape=none,texmode="raw"];
  M0F0 [label="\CbF{pull stock tp\_v} \FuTiReLa{M0}{F0}{none}"];
  M1F0 [label="... \FuTiReLa{M1}{F0}{none}"];
  M3F0 [label="... \FuTiReLa{M3}{F0}{none}"];
  M0F0 -> M1F0 [label="have stock",style="procFstD,thick"];
  M0F0 -> M3F0 [label="closed stock",style="procFstD,thick"];
}
\end{dot2tex}
\caption[Fusing pull instructions for an unshared stream]{Fusing pull instructions for an unshared stream; the left process can pull from the unshared stream, while the right process must wait for the first process to produce a value}
\label{figs/fsm/fuse-pulls}
\end{figure}

Each of the joint result labels represents a combination of two source labels, one from each of the source processes.
For example, the first joint label \FuTiReLa{M0}{F0}{none} represents a combination of the \lstiproc@map@ process being in its initial state \lstiproc@M0@ and the \lstiproc@regression@ process being in its own initial state \lstiproc@F0@. 
We also associate each of the joint labels with the \emph{input state}: a description of whether the \lstiproc@regression@ process has a value available to read from the shared \lstiproc@timeprices@ stream.
There is no value available, so the input state for \lstiproc@timeprices@ is set to \lstiproc@none@.
This extra information only applies to shared input streams; as such, the input state of the \lstiproc@map@ process is the empty map.

\subsubsection{Fusing Push with Pull}
\label{s:Fusion:FusingPushPull}

Next, \cref{figs/fsm/fuse-pushpull} shows the \lstiproc@map@ process pushing into the \lstiproc@timeprices@ stream after pulling a value from the \lstiproc@stock@ stream, while the \lstiproc@regression@ process is still trying to pull from the \lstiproc@timeprices@ stream.
After the \lstiproc@map@ process pushes a value, this value becomes available for the \lstiproc@regression@ process.
In the fused process, this situation results in two steps.
First, the \lstiproc@map@ process pushes the value (\lstiproc@tp_f tp_v@), and stores this value in the new local variable (\lstiproc@chan_tp@), so it is available for the \lstiproc@regression@ process.
The input state for the \lstiproc@regression@ process is updated to (\lstiproc@pending@), to signal that there is a value ready to be pulled in the (\lstiproc@chan_tp@) variable.
Next, the \lstiproc@regression@ process reads the \lstiproc@pending@ value, copying from the (\lstiproc@chan_tp@) variable into the (\lstiproc@reg_v@) variable.
The input state for the \lstiproc@regression@ process is updated to (\lstiproc@have@), to signal that the \lstiproc@regression@ process has copied the pulled value and is using it.

In the original process network, before any fusion, the \lstiproc@timeprices@ stream has two consumers: the \lstiproc@regression@ and \lstiproc@correlation@ processes.
Since the fused process implements both \lstiproc@map@ and \lstiproc@regression@ processes, the fused process still pushes to the \lstiproc@timeprices@ stream to allow the \lstiproc@correlation@ process to consume it.

\begin{figure}
\center
\begin{tabular}{ll||rr}
\begin{dot2tex}[dot]
digraph G {
node[shape=none,texmode="raw"];
edge[style="procFstD,thick"];
  M1 [label="\CbF{push timeprices (tp\_f tp\_v)} (M1)"];
  M2 [label="... (M2)"];
  M1 -> M2;
}
\end{dot2tex}
& \quad & \quad &
\begin{dot2tex}[dot]
digraph G {
node[shape=none,texmode="raw"];
edge[style="procSndD,thick"];
  F0 [label="\CbS{pull timeprices reg\_v} (F0)"];
  F1 [label="... (F1)"];
  F2 [label="... (F2)"];
  F0 -> F1[label="have timeprices"];
  F0 -> F2[label="closed timeprices"];
}
\end{dot2tex}
\end{tabular}
\vspace{1em}
\center
\begin{dot2tex}[dot]
digraph G {
node[shape=none,texmode="raw"];
  M1F0 [label="\CbF{push timeprices (tp\_f tp\_v)[chan\_tp=tp\_f tp\_v]} \FuTiReLa{M1}{F0}{none}"];
  M2F0 [label="\CbS{jump [reg\_v=chan\_tp]} \FuTiReLa{M2}{F0}{pending}"];
  M2F1 [label="... \FuTiReLa{M2}{F1}{have}"];
  M1F0 -> M2F0 [style="procFstD,thick"];
  M2F0 -> M2F1 [style="procSndD,thick"];
}
\end{dot2tex}
\caption[Fusing push with pull]{Fusing push with pull; the left process produces a value, which the right process consumes}
\label{figs/fsm/fuse-pushpull}
\end{figure}


\subsubsection{Fusion result}


\begin{lstlisting}[language=process,float,caption={[Fusion of timeprices and regression, along with shared instructions and variables]Fusion of \colorbox{procFst}{timeprices} and \colorbox{procSnd}{regression}, along with \colorbox{procCommon}{shared} instructions and variables},label=figs/procs/instance/fused-timeprices-regression,linebackgroundcolor={
  \hilineFst{2}
  \hilineFst{3}
  \hilineSnd{4}
  \hilineFst{5}
  \hilineSnd{6}
  \hilineCom{7}
  \hilineFst{10}
  \hilineFst{11}
  \hilineFst{12}
  \hilineFst{13}
  \hilineSnd{14}
  \hilineSnd{15}
  \hilineFst{16}
  \hilineFst{17}
  \hilineSnd{18}
  \hilineSnd{19}
  \hilineFst{22}
  \hilineFst{23}
  \hilineSnd{24}
  \hilineSnd{25}
  \hilineSnd{26}
  \hilineSnd{27}
  \hilineSnd{28}
  \hilineSnd{29}
  \hilineCom{30}
  \hilineCom{31}
  }]
process -- \colorbox{procFst}{map tp\_f stock timeprices} / \colorbox{procSnd}{foldl reg\_k reg\_z reg\_j timeprices reg\_out}
 { ins:    { stock  }
 , outs:   { timeprices
           , reg_out }
 , heap:   { tp_v
           , reg_s = reg_z, reg_v
           , chan_tp }
 , label:    M0_F0
 , instrs:
 { M0_F0   = pull stock tp_v M1_F0[] else M3_F0[]
 -- \FuTiReLa{M0}{F0}{none}; (LocalPull)
 , M1_F0   = push timeprices (tp_f tp_v) M2_F0_p[chan_tp = (tp_f tp_v)]
 -- \FuTiReLa{M1}{F0}{none}; (SharedPush)
 , M2_F0_p = jump M2_F1_h[reg_v = chan_tp]
 -- \FuTiReLa{M2}{F0}{pending}; (SharedPullPending)
 , M2_F1_h = drop stock M0_F1_h[] 
 -- \FuTiReLa{M2}{F1}{have}; (LocalDrop)
 , M0_F1_h = jump M0_F0[reg_s = reg_k reg_s reg_v]
 -- \FuTiReLa{M0}{F1}{have}; (ConnectedDrop)

 -- stock closed
 , M3_F0   = close timeprices M4_F0_c[] 
 -- \FuTiReLa{M3}{F0}{none}; (SharedClose)
 , M4_F0_c = jump M4_F2_c[] 
 -- \FuTiReLa{M4}{F0}{closed}; (SharedPullClosed)
 , M4_F2_c = push reg_out (reg_j reg_s) M4_F3_c 
 -- \FuTiReLa{M4}{F2}{closed}; (LocalPush)
 , M4_F3_c = close reg_out M4_F4_c[] 
 -- \FuTiReLa{M4}{F3}{closed}; (LocalClose)
 , M4_F4_c = exit
 -- \FuTiReLa{M4}{F4}{closed}; (LocalExit)
 } }
\end{lstlisting}

\Cref{figs/procs/instance/fused-timeprices-regression} shows the final result of fusing the \lstiproc@map@ and \lstiproc@regression@ processes together.
There are similar rules for handling the other combinations of instructions, but we defer the details to \cref{s:Fusion}.
The result process has one input stream, \lstiproc@stock@, and two output streams: \lstiproc@timeprices@ from \lstiproc@map@, and \lstiproc@reg_out@ from \lstiproc@regression@.

To complete the implementation of \lstiproc@priceOverTime@, we would now fuse this result process with the \lstiproc@correlation@ process.
Note that although the result process has a single shared heap, the heap bindings from each fused process are guaranteed not to interfere, as when we instantiate combinators to create source processes we introduce fresh names. 


\subsection{Join combinator}

To implement the whole \lstiproc@priceAnalyses@ process network, we also need the \lstiproc@join@ combinator, which pairs together the elements of two sorted input streams.
The combinator is parameterised by the key comparison function, which returns an \lstiproc@Ordering@ describing whether the key of the first argument is equal to the key of the second argument (\lstiproc@EQ@), lesser (\lstiproc@LT@), or greater (\lstiproc@GT@).
The process, shown in \cref{figs/procs/impl/join}, reads from two input streams (\lstiproc@sA@ and \lstiproc@sB@), and produces one output stream (\lstiproc@sOut@).
Two heap variables are used to store the most recent input elements (\lstiproc@va@ and \lstiproc@vb@), and another is used to store the key comparison (\lstiproc@c@).

\begin{process}[float,caption=Process implementation of \Hs/join/,label=figs/procs/impl/join]
join 
  = \ (cmp : a -> b -> Ordering)
      (sA  : Stream a) (sB : Stream b)
      (sOut: Stream (a,b)). 
    / (va : a) (vb : b) (c : Ordering) (...: Label).
    process
     { ins:    { sA, sB }
     , outs:   { sOut }
     , heap:   { va, vb, c }
     , label:  IN0
     , instrs: { IN0 = pull  sA va      IN1[] else DB0[]
               , IN1 = pull  sB vb      IN2[] else DA1[]
               , IN2 = jump             IN3[ c = cmp va vb ]
               , IN3 = case  (c == EQ)  EQ0[] else NE0[]

               -- cmp va vb $=$ EQ
               , EQ0 = push  sOut (a,b) EQ1[]
               , EQ1 = drop  sA         EQ2[]
               , EQ2 = drop  sB         IN0[]

               -- cmp va vb $\not=$ EQ
               , NE0 = case  (c == LT)  LT0[] else GT0[]

               -- cmp va vb $=$ LT
               , LT0 = drop  sA         LT1[]
               , LT1 = pull  sA va      IN2[] else DB1[]

               -- cmp va vb $=$ GT
               , GT0 = drop  sB         GT1[]
               , GT1 = pull  sB vb      IN2[] else DA1[]

               -- sB closed; drain sA
               , DA0 = pull  sA         DA1[] else EX0[]
               , DA1 = drop  sA         DA0[]

               -- sA closed; drain sB
               , DB0 = pull  sB         DB1[] else EX0[]
               , DB1 = drop  sB         DB0[]

               -- sA and sB closed
               , EX0 = close sOut       EX1[]
               , EX1 = exit } }
\end{process}

In the first group of instructions, the instructions at labels \lstiproc@IN0@ and \lstiproc@IN1@ pull an element from each input stream.
If both pulls are successful, the instruction at label \lstiproc@IN2@ compares the input values using the key comparison function (\lstiproc@cmp va vb@).
Next, the instruction at label \lstiproc@IN3@ checks whether the keys are equal: if so, execution proceeds to the instruction at label \lstiproc@EQ0@; otherwise, instruction proceeds to the instruction at label \lstiproc@NE0@.

The group of instructions at label \lstiproc@EQ0@ execute when the element keys are equal, and pushes the pair of elements to the output stream, before dropping both input streams.
Execution then proceeds back to the instruction at label \lstiproc@IN0@ to pull from the inputs.

The instruction at label \lstiproc@NE0@ executes when the element keys are not equal, and proceeds to the instruction at label \lstiproc@LT0@ if the first element is lesser, or to the instruction at label \lstiproc@GT0@ if the first element is greater.
These two groups of instructions drop the input stream with the lesser key and pull a new value from the same input stream, before returning back to the instruction at label \lstiproc@IN2@ to compare the elements.

The group of instructions at label \lstiproc@DA0@ executes when the \lstiproc@sB@ input stream is finished, while the \lstiproc@sA@ input stream may still have elements.
As with the polarised stream implementation of \lstiproc@join_iii@ in \cref{taxonomy/polarised}, we must drain the leftover elements from the unfinished stream by repeatedly pulling and dropping until there are no more elements.
This draining is required because, when fusing processes together, we treat each consumer as having a one-element buffer for each input stream; the producer can only push when all consumers' buffers are empty.
Without draining, the producer would be blocked indefinitely on the terminated \Hs/join/ process, and any other consumers of the stream would be unable to receive input values.

As an alternative to draining, we could extend the process network semantics to include a ``disconnect'' instruction, which indicates that a process is no longer interested in consuming a particular input stream.
Here, we use the simpler process semantics without disconnection, at the expense of having to explicitly drain streams.
It may be tempting to instead modify the network semantics so that producers do not push to terminated processes, effectively disconnecting the consumer from all inputs upon termination.
Such a change to the semantics would allow concurrent execution of unfused process networks with bounded buffers, without the processes having to perform draining.
However, a fused result process, which performs the job of two source processes, only terminates once both source processes have terminated; as such, the result process would only disconnect once both source processes have terminated, which may be later than necessary.

% In the @priceAnalyses@ example, the @stock@ input stream is used by two consumers, the @join@ in @priceOverMarket@, and the @map@ in @priceOverTime@.
% When a stream has multiple consumers, all consumers must agree when to read the next value, otherwise execution might require an unbounded buffer.
% This draining ensures that a producer will not 
% Without draining, the producer of the unfinished input stream would continue pushing to , potentially requiring an unbounded buffer; we look at draining in more detail in \REF{kpn/draining}.

The group of instructions at label \lstiproc@DB0@ executes when the \lstiproc@sA@ input stream is finished, and drains the unfinished \lstiproc@sB@ input stream.

Finally, the group of instructions at \lstiproc@EX0@ close the output stream and terminate the process.

\input{copy/03-body/02-process/s-process-def.tex}

\section{Fusion}
\label{s:Fusion}

Our core fusion algorithm constructs a static execution schedule for a single pair of processes.
In \cref{ss:Fusing:a:network}, we fuse a whole process network by fusing successive pairs of processes until only one remains.

\Cref{fig:Fusion:Types} defines some auxiliary grammar used during fusion. We extend the $\Label$ grammar with a new alternative, $\LabelF \times \LabelF$ for the labels in a fused result process. Each $\LabelF$ consists of a $\Label$ from a source process, paired with a map from $\Chan$ to the statically known part of that channel's current $\InputState$. When fusing a whole network, as we fuse pairs of individual processes the labels in the result collect more and more information. Each label of the final, completely fused process encodes the joint state that all the original source processes would be in at that point.

% The definition of $\Label$ is now recursive.
% These new labels $LabelF$ consist of a pair of source labels, as well as the static part of the $\InputState$ of each input channel.

% If the static $\InputStateF$ is $@pending@_F$, there is a value waiting to be pulled, do not know the actual value.

We also extend the existing $\Var$ grammar with a (@chan@ $c$) form which represents the buffer variable associated with \mbox{channel @c@}. We only need one buffer variable for each channel, and naming them like this saves us from inventing fresh names in the definition of the fusion rules.
We used the name (\lstiproc@chan_tp@) back in \cref{s:FusingProcesses} to avoid introducing a new mechanism at that point in the discussion, when in fact the fused process would use a buffer variable called (\lstiproc@chan timeprices@).

Still in \cref{fig:Fusion:Types}, $\ChanTypeTwo$ classifies how channels are used, and possibly shared, between two processes.
Type \lstiproc@in2@ indicates that both processes pull from the same channel, so these actions must be coordinated.
Type \lstiproc@in1@ indicates that only a single process pulls from the channel.
Type \lstiproc@in1out1@ indicates that one process pushes to the channel and the other pulls.
Type \lstiproc@out1@ indicates that the channel is pushed to by a single process.
Each output channel is uniquely owned and cannot be pushed to by more than one process.

\input{copy/03-body/02-process/figures/Fusion-types.tex}
\input{copy/03-body/02-process/figures/Fusion-fusePair.tex}


\smallskip
% -------------------------------------
\Cref{fig:Fusion:Def:Top} defines function \ti{fusePair}, which fuses a pair of processes, constructing a result process that does the job of both. We start with a joint label $l_0$ formed from the initial labels of the two source processes. We then use \ti{tryStepPair} to statically choose which of the two processes to advance, and hence which instruction to execute next. The possible destination labels of that instruction (computed with $outlabels$ from \cref{fig:Fusion:Utils}) define new joint labels and reachable states. As we discover reachable states, we add them to a map $bs$ of joint label to the corresponding instruction, and repeat the process to a fixpoint where no new states can be discovered.

\input{copy/03-body/02-process/figures/Fusion-tryStepPair.tex}

% -------------------------------------
\Cref{fig:Fusion:Def:StepPair} defines function \ti{tryStepPair}, which decides which of the two input processes to advance. It starts by calling \ti{tryStep} for both processes. If both can advance, we use heuristics to decide which one to run first.

Clauses (DeferExit1) and (DeferExit2) ensure that the fused process only terminates once both processes are ready to terminate; if either has remaining work, the process with remaining work will execute.
The clauses achieve this by checking if either process is at an \lstiproc@exit@ instruction, and if so, choosing the other process.
The instruction for the second process was computed by calling \ti{tryStep} with the label arguments swapped, so in (DeferExit2) we need to swap the labels back with $\ti{swaplabels}$ (from \cref{fig:Fusion:Utils}).
The result process terminates once both processes have terminated at an \lstiproc@exit@ instruction; in this case, clause (DeferExit1) will return the \lstiproc@exit@ instruction from the first process.

Clauses (PreferJump1) and (PreferJump2) prioritise processes that can perform a \lstiproc@jump@.
This helps collect \lstiproc@jump@ instructions together so they are easier for post-fusion optimisation to handle (\cref{s:Optimisation}).

Similarly, clauses (DeferPull1) and (DeferPull2) defer \lstiproc@pull@ instructions: if one of the instructions is a \lstiproc@pull@, we advance the other one. We do this because \lstiproc@pull@ instructions may block, while other instructions are more likely to produce immediate results.

Clauses (Run1) and (Run2) apply when the above heuristics do not apply, or only one of the processes can advance.
% We try the first process first, and if that can advance then so be it. This priority means that fusion is left-biased, preferring advancement of the left process over the second.

Clause (Deadlock) applies when neither process can advance, in which case the processes cannot be fused together and fusion fails.


\input{copy/03-body/02-process/figures/Fusion-tryStep.tex}

% -------------------------------------
\smallskip
\Cref{fig:Fusion:Def:Step} defines function \ti{tryStep}, which schedules a single instruction.
This function takes the map of channel types, along with the current label and associated instruction of one process (which we call the left process), and the current label of the other (right) process.
The \ti{tryStep} function is called twice in \ti{tryStepPair}, once for each process, so the left process may correspond to either input process at any given time.


Clause (LocalJump) applies when the left process wants to jump.
In this case, the result instruction simply performs the corresponding jump, leaving the right process where it is.
This clause corresponds to a static version of the rule (Jump) for advancing processes during execution (\cref{s:Process:Eval}).

Clause (LocalCase) is similar, except there are two $\Next$ labels.

Clause (LocalPush) applies when the left process wants to push to a non-shared output channel.
In this case the push can be performed directly, with no additional coordination required.

Clause (SharedPush) applies when the left process wants to push to a shared channel.
Pushing to a shared channel requires the downstream process to be ready to accept the value at the same time.
We encode this constraint by requiring the static input state of the downstream channel to be $@none@_F$.
When this constraint is satisfied, the result instruction stores the pushed value in the stream buffer variable $(@chan@~c)$ and sets the static input state to $@pending@_F$, which indicates that the new value is now available.
This clause corresponds to a static version of the evaluation rule (Push) for advancing the left process, combined with the rule (InjectPush) for injecting the push action into the right process.

Still in \cref{fig:Fusion:Def:Step}, clause (LocalPull) applies when the left process wants to pull from a local channel, which requires no coordination.

Clause (SharedPullPending) applies when the left process wants to pull from a shared channel that the other process either pulls from or pushes to.
We know that there is already a value in the stream buffer variable, because the state for that channel is $@pending@_F$.
The result instruction copies the value from the stream buffer variable into a variable specific to the left source process.
The corresponding $@have@_F$ channel state in the result label records that the value has been successfully pulled.

Clause (SharedPullClosed) applies when the left process wants to pull from a shared channel that the other process either pulls from or pushes to, and the channel is closed.
The result instruction jumps to the close output label.

Clause (SharedPullInject) applies when the left process wants to pull from a shared channel that both processes pull from, and neither already has a value.
The result instruction is a \lstiproc@pull@ that loads the stream buffer variable, leaving the labels the same and updating the channel state for both processes.
In the next instruction, the left process will try to pull again with the updated channel state, and one of the clauses (SharedPullPending) or (SharedPullClosed) will apply.

Clause (LocalDrop) applies when the left process wants to drop the current value that it read from an unshared input channel, which requires no coordination.

Clause (ConnectedDrop) applies when the left process wants to drop the current value that it received from an upstream process. As the value will have been sent via a heap variable instead of being pulled from a channel, the result instruction just performs a \lstiproc@jump@ while updating the static channel state.

Clauses (SharedDropOne) and (SharedDropBoth) apply when the left process wants to drop from a shared channel that is read by both processes. In (SharedDropOne), the channel states reveal that the other process is still using the value. In this case, the result instruction is a \lstiproc@jump@ updating the channel state to note that the left process has dropped. In (SharedDropBoth), the channel states reveal that the other process has already dropped its copy of the channel value using clause (SharedDropOne). In this case, the result instruction is a real \lstiproc@drop@, because we are sure that neither process requires the value any longer.

Clause (LocalClose) applies when the left process wants to close an unshared output channel, which requires no coordination.

Clause (SharedClose) applies when the left process wants to close a shared output channel that the other process pulls from.
Closing the channel updates the channel state and requires the downstream process to have dropped any previously read values, just as the (InjectClose) evaluation rule requires the downstream process to have \lstiproc@none@ as its input state.

Clause (LocalExit) applies when the left process wants to finish execution, which requires no coordination here, but causes the other process to be prioritised in the (DeferExit) clauses in the earlier definition of \ti{tryStepPair}.

Clause (Blocked) returns \lstiproc@Nothing@ when no other clauses apply, meaning that this process is waiting for the other process to advance.

All the clauses in the \ti{tryStep} function work together to perform a static version of the dynamic process execution.
Each clause checks whether the left process can advance given the statically known channel state.
When the left process advances normally in the dynamic execution rules, it produces an output action to be injected into other processes in the network.
The clauses in \ti{tryStep} statically coordinate with the right process, checking whether the result action from advancing the left process can be injected into the right process, given the statically known channel state of the right process.
Although there are many clauses, the translation from the advance and injection rules to the clauses is relatively straightforward.

\smallskip

% -------------------------------------
\input{copy/03-body/02-process/figures/FusionUtils.tex}

\Cref{fig:Fusion:Utils} contains definitions of some utility functions which we have already mentioned.
Function \ti{channels} computes the $\ChanType_2$ map for a pair of processes.
Function \ti{outlabels} gets the set of output labels for an instruction, which is used when computing the fixpoint of reachable states.
Function \ti{swaplabels} flips the order of the compound labels in an instruction.

\subsection{Static deadlock detection}
\label{process/static-deadlock}

In the definition of \ti{tryStep}, clause (Blocked) applies when the source process is waiting for the other process to advance.
If both processes are blocked waiting for each other, then the two processes are stuck.
Clause (Deadlock) from \ti{tryStepPair} applies, and fusion fails.

This fusion failure corresponds to a static approximation of deadlock detection.
As observed by \citet{buck1993scheduling}, static deadlock detection for Kahn process networks is in general undecidable.
Our deadlock detection is sound, but not complete.
If we detect a deadlock statically, then concurrent execution of the original Kahn process network may or may not deadlock at runtime.
If we do not detect a deadlock, then the original Kahn process network is guaranteed to be free from deadlocks.

Deadlock detection algorithms for Kahn process networks do exist, but perform deadlock detection dynamically rather than statically \citep{allen2007distributed,jiang2008hierarchical}.
% \citep{allen2007distributed,bharath2004runtime,jiang2008hierarchical,olson2005deadlock}.
These algorithms tend to focus on \emph{artificial deadlocks}, which are deadlocks introduced by restricting the size of channel buffers.
Artificial deadlocks are identified dynamically, and resolved by increasing the buffer size \citep{geilen2003requirements,parks1995bounded}.
Because these systems perform dynamic scheduling and deadlock detection, process networks using these systems tend to require larger, more coarse-grained processes to offset the dynamic scheduling overhead \citep{chen1990impact}.


% \input{copy/03-body/02-process/s-fusibility.tex}

\input{copy/03-body/02-process/s-drop.tex}
\input{copy/03-body/02-process/s-transforming.tex}

% -----------------------------------------------------------------------------


\section{Proofs}
\label{s:Proofs}

Our fusion system is formalised in Coq\footnote{\url{https://github.com/amosr/papers/tree/master/2017mergingmerges/proof}}, and we have proved soundness of \ti{fusePair}: if the fused result process produces a particular sequence of values on its output channels, then this is one of the possible sequences that would be produced by the two source processes.
Note that due to the non-determinism of process execution, the converse is not true for all source processes: just because the two concurrent processes can produce a particular output sequence does not mean the fused result process will as well --- the fused result process uses only one of the many possible orders.
However, because the result of evaluating a Kahn process network to completion \emph{is} deterministic, we should be able to prove that, if fusion succeeds, the result process produces the same overall result despite using potentially different interleavings.
The proof of result determinism is left to future work.
% However, because the result of evaluating a Kahn process network

The proof of soundness is stated as follows:

% Note that the converse is not necessarily true: just because two processes can evaluate to a particular output does not mean the fused program will evaluate to that. This is because, as explained in~\cref{s:EvaluationOrder}, evaluation of a process network is non-deterministic, and fusion commits to a particular evaluation order.

\begin{coq}
Theorem Soundness (P1 : Program L1 C V1) (P2  : Program L2 C V2)
                  (ss : Streams)         (h   : Heap)
                  (l1 : L1)              (is1 : InputStates C)
                  (l2 : L2)              (is2 : InputStates C)
  :  EvalN (fuse P1 P2) ss h (LX l1 l2 is1 is2)
  -> EvalNOriginal Var1 P1 P2 is1 ss h l1
  /\ EvalNOriginal Var2 P2 P1 is2 ss h l2.
\end{coq}

The @Soundness@ theorem uses the relational predicate @EvalN@ to evaluate the fused program, and the predicate @EvalNOriginal@ ensures that the original program evaluates with that program's subset of the result heap, using @Var1@ and @Var2@ to extract the variables.
The @Streams@ type corresponds to the channel value map used to accumulate stream elements while feeding a process network (\cref{fig:Process:Eval:Feed}), and the @Heap@ type corresponds to the value store used while advancing a single process (\cref{fig:Process:Eval:Shake}).

% Care must be taken to remove stream values that the other process has pulled but this one has not yet.
%%% AR: Really would like to say something about this but no room to explain properly
% For shared inputs when one program has pulled, the other program must be evaluated with the other value removed from the end of the stream.


The Coq formalisation has some differences and simplifications from the system presented earlier in this chapter.
The most important difference is that the processes in the Coq formalisation operate on infinite streams, whereas our earlier presentation used finite streams.
This simplification means that \Hs@pull@ instructions take only one output label rather than two, and we do not need the \Hs@close@ or \Hs@exit@ instructions.
In the earlier presentation of fusion, the \Hs/close/ instruction performed fundamentally the same communication as the \Hs/push/ instruction, except that it sent a `close' message instead of a `push' message.
The earlier presentation of the fusion algorithm used the same static input states of the processes to fuse both forms of communication, so in this sense the \Hs/push/ instruction is representative of the communication involved in the \Hs/close/ instruction.
Removing the \Hs/close/ instruction from the formalisation does not limit the processes that can be expressed, as finite streams can be represented by pushing a sentinel value that represents the end of the stream.
However, the infinite-stream fusion algorithm does not statically reason about pushed and pulled values, and cannot statically determine whether an infinite stream has `finished'.
Therefore, the infinite-stream fusion algorithm may fail for some processes that use infinite encodings of finite-streams, while the finite-stream presentation would succeed.
In the earlier presentation of fusion, the \Hs/exit/ instruction performed no direct communication between the two processes, and the corresponding clause in the fusion algorithm was straightforward.
For processes that operate over infinite streams, the \Hs/exit/ instruction is not required as processes can just continue to pull from the input stream.
The algorithm is conceptually the same despite this simplification to use infinite streams.

The Coq formalisation also uses a separate \Hs@update@ instruction to modify variables in the local heap, rather than attaching heap updates to the \Next~ label of every instruction.
Performing this desugaring makes the low-level lemmas easier to prove, but we find attaching the updates to each instruction makes for an easier exposition.
Having a separate \Hs@update@ instruction causes the fusion definition to be slightly more complicated, as two output instructions must be emitted when performing a push or pull followed by an update.

The following datatype defines the available instructions in the formalisation:

\pagebreak
\begin{coq}
Inductive Instruction : Type :=
  | Pull    : ScalarV -> ChanV           -> Label -> Instruction
  | Push    : ChanV   -> (Heap -> Value) -> Label -> Instruction
  | Drop    : ChanV                      -> Label -> Instruction
  | Update  : ScalarV -> (Heap -> Value) -> Label -> Instruction
  | IfZero  : (Heap -> Value)   -> Label -> Label -> Instruction
  | Jump    :                               Label -> Instruction.
\end{coq}

In the above inductive definition, the type \Hs@ScalarV@ denotes a scalar variable; \Hs@ChanV@ denotes a channel name to pull from or push to; \Hs@Label@ denotes an output label to transfer control to; \Hs@Heap@ denotes a heap that can be addressed by scalar variables and contains scalar values; and \Hs@Value@ denotes a scalar value, which for formalisation purposes are just natural numbers.
We represent expressions as functions in the meta-language using the type \Hs@(Heap -> Value)@.

\begin{figure}
\begin{coq}
Inductive Eval1 : Streams -> Heap -> Label -> Instruction
               -> Streams -> Heap -> Label -> Prop :=
  | EvalPull (ss : Streams) (h : Heap) (l l' : Label)
             (var : ScalarV) (chan : ChanV) (val : Value)
     : StreamType chan = Input
    -> Eval1        ss                           h  l (Pull var chan l')
            (insert ss chan val) (update var val h) l'

  | EvalPush (ss : Streams) (h : Heap) (l l' : Label) (chan : ChanV) (f : Heap -> Value)
     : StreamType chan = Output
    -> Eval1         ss             h l (Push chan f l')
             (insert ss chan (f h)) h l'

  | EvalDrop (ss : Streams) (h : Heap) (l l' : Label) (chan : ChanV)
     : StreamType chan = Input
    -> Eval1 ss h l (Drop chan l')
             ss h l'

  | EvalUpdate (ss : Streams) (h : Heap) (l l' : Label)
               (var : ScalarV) (f : Heap -> Value)
     : Eval1 ss                   h  l (Update var f l')
             ss (update var (f h) h) l'

  | EvalIfZ (ss : Streams) (h : Heap) (l lz lnz : Label) (f : Heap -> Value)
     : Eval1 ss h l (IfZero f lz lnz)
             ss h (if Nat.eqb (f h) 0 then lz else lnz)

  | EvalJump (ss : Streams) (h : Heap) (l l' : Label)
     : Eval1 ss h l (Jump l')
             ss h l'

  | EvalIgnore (ss : Streams) (h : Heap) (l l' : Label) (instr : Instruction)
              (chan : ChanV) (val : Value)
     : StreamType chan = Ignore
    -> Eval1         ss           h l instr
             (insert ss chan val) h l.
\end{coq}
\caption{Single-step execution of process in Coq formalisation}
\label{figs/coq/single-step}
\end{figure}

Furthermore, the formalisation only implements sequential evaluation for a single process, rather than non-deterministic evaluation for whole process networks.
Instead, we sequentially evaluate each source process independently, and compare the output values to the ones produced by sequential evaluation of the fused result process.
\Cref{figs/coq/single-step} shows the definition of the inductive relation \Hs@Eval1@, which denotes a single step of sequentially evaluating a process.
Conceptually, the \Hs@Eval1@ relation takes as input a map of collected values for all channels (\Hs@Streams@), a scalar heap (\Hs@Heap@), and the currently executing label (\Hs@Label@) and instruction (\Hs@Instruction@) of the process.
As output, the relation gives the updated map of channel values, the updated scalar heap, and the new label at which execution should continue.
To model the sequential evaluation of a single process in isolation, it would be sufficient to design a semantics where values on input streams were given as a separate channel values map.
In such a semantics, the map of channel values is given to the evaluation relation when evaluation starts, so the entire input stream must be known ahead of time.
Such a semantics would complicate our proofs, as we wish to reason about the sequential evaluation of a process in the context of other concurrent processes; in addition, input streams may be infinite.
We instead store input and output streams uniformly in the same channel values map, and conceptually treat the returned channel values map as a record of pull and push interactions with the surrounding network.

The \Hs@EvalPull@ constructor of \Hs@Eval1@ corresponds to the execution of a pull instruction. 
In this case the process wishes to pull a value from the surrounding network, but as our semantics does not explicitly represent the surrounding network or the input values, we do not know the exact value that is available on the channel.
Instead, we allow the environment to choose the pulled value, and then record that this particular value was read from the surrounding network.
When reasoning about a pair of processes to be fused, the value pulled by one process may have been pushed by the other process.
Deferring the choice of the particular value until the value is pulled, rather than specifying all input values ahead of time, simplifies the formalisation of correctness of fusion.

The \Hs/EvalPush/ constructor interacts with the \Hs/Streams/ channel value map in a similar way to the \Hs/EvalPull/ constructor, except in this case the pushed value is dictated by the expresion (\Hs/f/), rather than being an arbitrary value provided by the environment.

The remaining constructors are quite similar to the rules for advancing processes given in \cref{s:Process:Eval}, except for the final constructor \Hs/EvalIgnore/.
The \Hs/EvalIgnore/ constructor is similar to the \Hs/EvalPull/ constructor, in that it represents communication with the surrounding network.
In this case, the particular channel is not pulled from or pushed to by the process.
When fusing a pair of processes, one process may pull from or push to a channel that the other ignores; this constructor allows the process that ignores the channel to record these values in the channel value map, but the process itself cannot observe the values.

\begin{figure}
\begin{coq}
Variable Instructions : Label -> Instruction.
Variable Init         : Label.

Inductive EvalN : Streams -> Heap -> Label -> Prop :=
  | Eval0
     : EvalN (fun _ => []) (fun _ => 0) Init
  | EvalSuc (l l' : Label) (ss ss' : Streams) (h h' : Heap)
     : EvalN ss h l
    -> Eval1 ss h l (Instructions l) ss' h' l'
    -> EvalN                         ss' h' l'.
\end{coq}
\caption{Multiple-step execution of process in Coq formalisation}
\label{figs/coq/multi-step}
\end{figure}

\Cref{figs/coq/multi-step} shows the definition of the multiple-step evaluation relation of a process.
Constructor \Hs@Eval0@ starts evaluation with channel values map consisting of empty lists, an empty heap, and starting at the initial label (\Hs/Init/).
Constructor \Hs/EvalSuc/ appends a single step of evaluation to the end of an existing multiple-step evaluation, using the mapping from label to instructions (\Hs/Instructions/) to find the corresponding instruction to evaluate.

\begin{figure}
\begin{coq}
Record Program (Label : Set) (ChanV : Set) (ScalarV : Set) : Type
 := mkProgram
  { ChanVEqDec      : EqDec ChanV
  ; ScalarVEqDec    : EqDec ScalarV
  ; StreamType      : ChanV -> StreamTypeT

  ; Init            : Label
  ; Instructions    : Label -> Instruction Label ChanV ScalarV

  ; LabelInvariants : Label -> Streams ChanV -> Heap ScalarV -> Prop
  ; Invariant0:
      LabelInvariants Init (fun _ => []) (fun _ => 0)
  ; InvariantSuc:
       forall (l l' : Label) (ss ss' : Streams ChanV)
                             (h h' : Heap ScalarV),
       LabelInvariants l ss h
    -> Eval1 ChanVEqDec ScalarVEqDec StreamType
                       ss h l (Instructions l) ss' h' l'
    -> LabelInvariants l' ss' h'
  }.
\end{coq}
\caption{Program definition in Coq formalisation}
\label{figs/coq/program}
\end{figure}

\Cref{figs/coq/program} shows the definition of \Hs/Program/, which is a convenience record type that ties together all the different parts required to define a program.
The program is parameterised by the types of labels, channel variables, and scalar variables.
The \Hs/ChanVEqDec/ field is a predicate to check whether two channel variables are equal; this predicate is used when updating the channel values map during evaluation.
Similarly, the \Hs/ScalarVEqDec/ field is used to update the scalar heap.
The \Hs/StreamType/ field describes whether each channel is pulled from (\Hs/Input/), pushed to (\Hs/Output/), or neither (\Hs/Ignore/).
The \Hs/Init/ and \Hs/Instructions/ fields define the initial label and the mapping from labels to instructions.
For reasoning about program evaluations, the \Hs/LabelInvariants/ field associates each label with an invariant, which is expressed as a predicate of the evaluation state.
The \Hs/Invariant0/ and \Hs/InvariantSuc/ fields ensure that the invariant is established and maintained, respectively.
The \Hs/Invariant0/ field ensures that the invariant for the initial label holds for the initial evaluation state.
The \Hs/InvariantSuc/ field ensures that whenever the program takes an evaluation step, assuming the invariant for the original label was satisfied at the start of the step, the invariant for the result label must be satisfied by the updated evaluation state.
Thus, each label's invariant serves the purpose of both precondition for the corresponding instruction, and postcondition for predecessor instructions.
These two facts are sufficient to show that all possible evaluations respect the invariants, by performing induction over \Hs/EvalN/.

The fusion algorithm from \cref{s:Fusion} takes two processes as input, and constructs a new process by starting from the initial labels and iteratively inserting new instructions into the mapping from label to instructions.
After inserting a new instruction into the map, the algorithm proceeds to insert the instructions corresponding to the destination labels as necessary.
This insertion step is repeated until all destination labels have been searched, or until a fusion failure is encountered.
This algorithm is terminating, as both input processes have a finite number of labels and the set of fused label is finite, but encoding this repeated insertion step in Coq requires a non-trivial proof of termination.
We sidestep this issue by representing the mapping from label to instruction as a total function that does not need to be inserted into, and by deferring the check for fusion failure until evaluation.
\Cref{figs/coq/fused-label} shows the definition of labels and variables in the resulting fused process; fusion is parameterised over the variable (\Hs/V1/ and \Hs/V2/), label (\Hs/L1/ and \Hs/L2/), and channel (\Hs/C/) types of the two input programs (\Hs/P1/ and \Hs/P2/).
The label \Hs/LX/ denotes a fused label, and contains the labels and input states of each input process.
The label \Hs/L'INVALID/ denotes an invalid process state, and corresponds to fusion failure in the original algorithm.
In the formalisation, fusion always produces a result program, but if the state \Hs/L'INVALID/ is statically reachable then the original fusion algorithm would have failed.
Despite the presence of invalid states, we can still reason about valid evaluations by restricting our attention to evaluations that end in an \Hs/LX/ label.
The variable constructors \Hs/V'V1/ and \Hs/V'V2/ correspond to a process in each of the original input processes, while the variable \Hs/V'C/ corresponds to a buffer variable, used to temporarily store a single pulled or pushed value on a channel.

\begin{figure}
\begin{coq}
Variable L1 V1 L2 V2 C : Set.
Variable P1 : P.Program L1 C V1.
Variable P2 : P.Program L2 C V2.

Inductive L' :=
  | LX (l1 : L1) (l2 : L2) (is1 : InputStates C) (is2 : InputStates C)
  | L'INVALID.

Inductive V :=
  | V'V1 : V1 -> V
  | V'V2 : V2 -> V
  | V'C : C -> V.
\end{coq}
\caption{Labels and variables in the fused process in Coq formalisation}
\label{figs/coq/fused-label}
\end{figure}

For the fused result process, we define the following invariant that all evaluations of the result process must satisfy:
\begin{coq}
Definition invariant (l : L') (ss : Streams C) (h : Heap V) : Prop :=
 match l with
  | L'INVALID        => True
  | LX l1 l2 is1 is2 => invariantPX V'V1 P1 P2 is1 l1 ss h
                     /\ invariantPX V'V2 P2 P1 is2 l2 ss h
 end.
\end{coq}

In the case that the result process has evaluated to an \Hs/L'INVALID/ label, fusion would have failed, and we do not know anything about the evaluation state that led to this failure.
A process that has reached \Hs/L'INVALID/ will always remain at the \Hs/L'INVALID/ label.
When the result process has evaluated to an \Hs/LX/ label, we use the function \Hs/invariantPX/ to show how the current evaluation state corresponds to the evaluation of each input process separately, as well as how the two input processes correspond to each other.
The \Hs/V'V1/ and \Hs/V'V2/ arguments to \Hs/invariantPX/ describe how to access each individual input process' portion of the scalar heap.

\begin{figure}
\begin{coq}
Let originalStreams (is : InputStates C) (ss : Streams C) : Streams C :=
  fun c => match is c with
            | AvailableToPull => tail (ss c)
            | HaveValue       =>       ss c
            | NoValue         =>       ss c
            | ReadyToPush     =>       ss c
           end.

Let originalHeap (VA : Set) (VX : VA -> V) (h : Heap V) : Heap VA :=
  fun v => h (VX v).

Let invariantPX (LA VA LB VB : Set) (VX : VA -> V)
                (PA : Program LA C VA) (PB : Program LB C VB) (is : InputStates C)
                (l : LA) (ss : Streams C) (h : Heap V) : Prop :=

    let pOriginal  := EvalN PA (originalStreams is ss) (originalHeap VX h) l

 in let pAvailable := forall c, s c = AvailableToPull
                   -> head (iss c) = Some (h (V'C c))

 in let pReady     := forall c, s c = ReadyToPush
                   -> exists f l', Instructions PA l = Push c f l'
                   /\ h (V'C c) = f (originalHeap VX h)

 in let pInput     := forall c, StreamType PA c = Input
                   -> s c = NoValue \/ s c = AvailableToPull \/ s c = HaveValue

 in let pOutput    := forall c, StreamType PA c = Output
                   -> s c = NoValue \/ s c = AvailableToPull \/ s c = ReadyToPush

 in let pIgnore    := forall c,
                      StreamType PA c = Ignore \/ StreamType PB c = Ignore
                   -> s c = NoValue

 in pOriginal /\ pAvailable /\ pReady /\ pInput /\ pOutput /\ pIgnore.
\end{coq}
\caption{Fused process invariant definition in Coq formalisation}
\label{figs/coq/fused-invariant}
\end{figure}

\Cref{figs/coq/fused-invariant} shows the definition of \Hs/invariantPX/, along with some helper functions.
The \Hs/originalStreams/ and function takes the current state of the stream value map according to the fused result process, and returns the portion of the stream value map that is currently visible to the original input process.
The \Hs/Streams/ type is represented as a function from channel name to list of stream values, in order of most recently pushed first.
Usually the two stream value maps are the same, except in the following case.
When one of the input processes has just pushed to a channel that the other pulls from, that channel becomes marked as \Hs/AvailableToPull/ in the input states of the pulling process.
In this instance, the stream values map for the result fused process will contain the pushed value, but because the pulling process has not yet read the value, it is not visible in the stream values map for the pulling process.
The definition of \Hs/originalStreams/ removes the most recently pushed element from the stream.
The \Hs/originalHeap/ function computes the subset of the heap containing only the scalar variables for the given process. As with \Hs/Streams/, the \Hs/Heap/ type is represented as a function.

Still in \cref{figs/coq/fused-invariant}, the definition of \Hs/invariantPX/ contains several properties that hold for each evaluation.
Property \Hs/pOriginal/ requires that the original input process can be evaluated to the current label with the corresponding original stream value map and heap.
This property corresponds to the definition of \Hs/EvalNOriginal/ in the statement of overall \Hs/Soundness/ from earlier; the remaining properties are strengthenings of the invariant that are required to show that \Hs/pOriginal/ is maintained.
Property \Hs/pAvailable/ requires that after one process pushes a value to a shared channel, then the corresponding channel buffer variable contains the same value.
In the fused process, the pull from the shared channel will use the channel buffer variable instead of reading from the stream, and this ensures that both receive the same value.
In the formalisation, the fused result process pushes to a shared channel in two steps: first, the channel buffer variable is set to the pushed value, then the value is pushed.
Property \Hs/pReady/ joins these two steps together, and applies when the process has updated the channel buffer variable but not yet pushed the value.
In this case, the next instruction must push the same value as is currently in the channel buffer variable.
Properties \Hs/pInput/ and \Hs/pOutput/ restricts the possible input states, depending on whether the current input process pulls from or pushes to the channel.
Finally, if either of the input processes ignores a channel, it is not required to track that channel's input state. 
Property \Hs/pIgnore/ requires that the input state for ignored channels is always \Hs/NoValue/.

Proving that the invariant is established initially is straightforward, as the channel value map is empty and the result process' initial heap contains both source processes' initial heaps.
To prove that the invariant is maintained for a particular label in the result process, we perform case distinction on the instruction corresponding to the label, then, as necessary, perform case distinction on the original source process instructions.
With the invariant established and maintained, we prove the \Hs/Soundness/ theorem by performing induction over the evaluation relation, and showing that all evaluations of the result process respect the invariant.
We believe that this formalisation gives sufficient confidence in the correctness of the presentation given earlier, despite the differences in formulation.

% To prove soundness of fusion, we assert the invariant that defines how evaluation of the fused program relates to evaluation of the two original programs. 
% For the fused process, the invariant is that, when the fused process evaluates to a particular evaluation state, then each original process must
% \TODO{example evaluation, show how evaluation relation works with @pending@ values}
% 
% \TODO{also mention that formalisation is infinite streams, rather than finite}

% \TODO{Interesting things to detail: the formulation of external events (hinted at above); the problem with encoding fixpoint in Coq, and necessity to define fused process `lazily', which requires the addition of the `INVALID' state. Could include definition of Block (instruction) type, and definition of evaluation relation.}
