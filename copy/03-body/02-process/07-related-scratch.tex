Kilim \cite{srinivasan2010kilim} is an implementation of lightweight actors for the JVM.
Kilim uses linear types to ensure that messages are not aliased between actors.
Has a postprocessor called the `weaver' which operates over the java bytecode to remove the overhead of actually performing actors as separate threads.
This is more like modifying the Java bytecode to store explicit continuations on the stack, and still uses runtime scheduling.



Some introduction is required before delving into the details of \emph{process fusion}.
Fusion is first and foremost an optimisation for making programs run faster - but there are two main parts to this.
Firstly, by fusing two loops together, the loop overhead that was previously paid twice is now only paid once.
That is, the second set of looping instructions are removed from the program.
This has some benefit, but generally only in cases where the loops are small: if the loops were performing more than a few instructions, its cost would outweigh the negligible amount of loop overhead.

The real benefit of fusion comes from the fact that the fused program now has different space and time locality: by moving the instructions that write to an array next to instructions that read that same value, the value is more likely to be held in a register or in cache, saving a potentially expensive memory lookup.
The intermediate array can also be removed from memory, but this is more of a side-benefit than anything else.
In imperative languages, removing intermediate arrays is performed as a separate step called array contraction.

It is possible to perform fusion while keeping intermediate arrays; for example partitioning a stream into those greater than or equal to zero (`aboves'), and those below zero (`belows'), and appending the aboves to the belows.

\begin{code}
partitions :: Stream Int -> Stream Int
partitions inputs =
 let aboves      = filter (>=0) inputs
     belows      = filter  (<0) inputs
     partitioned = aboves ++ belows
 in  partitioned
\end{code}

\FigurePdf{figs/combinators/filter-even-odd}{Pairing even/odd: combinator diagram}{Combinator diagram for pairing even/odd.}

\Cref{figs/combinators/filter-even-odd} shows the combinator diagram for partitions.
This operation inherently requires a buffer, as the entire stream must be read in order to compute the aboves, and the append must wait until the end of aboves before it can read from belows.
This operation can be fused together by using an intermediate buffer to store belows in, as values are read from inputs.

\begin{code}
partitions inputs =
 output partitioned.
 let go buf = do
       v <- pull inputs (finish buf)
       case v >= 0 of
        True -> do
         push partitioned v
         go buf
        False -> do
         go (Buf.push buf v)
     finish buf = case Buf.uncons buf of
       Just (v,buf') -> do
         push partitioned v
         finish buf'
       Nothing -> do
         done
 in  go Buf.empty
\end{code}

If the input happens to be a manifest array, then the buffer is already there - one could loop over the array twice, or even reuse parts of the array in-place similar to the partition in quicksort.
However, when the input is a stream of unknown size, this buffering can cause space issues.
If the input stream does not fit entirely in memory, storing even a subset of elements in an unbounded buffer is likely to run out of memory at some stage---and running out of memory could very well mean a terminated program.

We are therefore not just interested in fusing programs, but fusing them without unbounded buffers, even at the expense of expressivity.
For this reason, the main fusion algorithm does not handle any insertion of buffers.

