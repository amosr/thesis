%!TEX root = ../Main.tex
\section{Intermediate Language}
\label{icicle:s:IcicleCore}

The Icicle intermediate language is similar to a physical query plan for a database system.
We convert each source level query to a query plan, then fuse together the plans for queries on the same table.
Once we have the fused query plan we then perform standard optimisations such as common subexpression elimination and partial evaluation.

The grammar for the Icicle intermediate language is given in \autoref{icicle:fig:core:grammar}.
Expressions $PlanX$ include variables, values, applications of primitives and anonymous functions.
Function definitions and uses are not allowed in expressions here, as their definitions are inlined before converting to query plans.
Anonymous functions are only allowed as arguments to primitives: they cannot be applied or stored in variables.
The primitives of the source language are extended with key-value map primitives, which are used for implementing groups.
Folds are defined in $\mi{PlanF}$ and can be nested inside a filter, in which case the fold update is only performed when the predicate is true; the nested fold binding is available outside of the filter.
Folds nested inside a group are performed separately for each key; the nested fold binds a key-value map instead of a single value.
The $\mi{Plan}$ itself is split into a five stage \emph{loop anatomy}~\cite{shivers2005anatomy}.
First we have the name of the table and the names and element types of each column.
The @before@ stage then defines pure values which do not depend on any table data.
The @folds@ stage defines element computations and how they are converted to aggregate results.
The @after@ stage defines aggregate computations that combine multiple aggregations after the entire table has been processed.
Finally, the @return@ stage specifies the output values of the query; a single query will have only one output value, but the result of fusion can have many outputs.

\begin{figure}

\begin{tabbing}
MMM \= MM \= MMMM \= MMMM \= MMMMMM \= \kill
$\mi{PlanX}$
\GrammarDefTab
  $x~|~V~|~\mi{PlanP}~\ov{\mi{PlanX}}~|~\lam{x}\mi{PlanX}$
\\
$\mi{PlanP}$
\GrammarDefTab
  $\mi{Prim}~|~@mapUpdate@~|~@mapEmpty@~|~@mapMap@~|~@mapZip@$
\\
$\mi{PlanF}$
\GrammarDefTab
 $@fold@$ \> $~~x~:~T~=~\mi{PlanX}~@then@~\mi{PlanX};$
\GrammarAlt
 $@filter@$ \> $\mi{PlanX}$ \> $\{~\ov{\mi{PlanF}}~\}$
\GrammarAlt
  $@group@$ \> $\mi{PlanX}$ \> $\{~\ov{\mi{PlanF}}~\}$
\\
\\
$\mi{Plan}$
\GrammarDefTab
  $@plan@~x$ \> $\{~\ov{x~:~T;}~\}$
\\
  \> \> $@before@$ \> $\{~\ov{x~:~T~=~\mi{PlanX};}~\}$ \\
  \> \> $@folds@$  \> $\{~\ov{\mi{PlanF}}~\}$ \\
  \> \> $@after@$  \> $\{~\ov{x~:~T~=~\mi{PlanX};}~\}$ \\
  \> \> $@return@$ \> $\{~\ov{x~:~T~=~x;}~\}$ \\
\end{tabbing}



\caption{Query Plan Grammar}
\label{icicle:fig:core:grammar}
\end{figure}


Before we discuss an example query plan we first define the @count@ and @sum@ functions used in earlier sections.
Both functions are simple folds:
\begin{icicle}
function count
 = fold c = 0 then c + 1;

function sum (e : Element Int)
 = fold s = 0 then s + e;
\end{icicle}

Inlining these functions into the three stocks queries from \hyperref[icicle:s:Introduction]{the start of the chapter} yields the following set of queries:

\begin{icicle}
table stocks { open : Int, close : Int }
query 
  more = filter open > close of (fold more_c = 0 then more_c + 1);
  less = filter open < close of (fold less_c = 0 then less_c + 1);
  mean = filter open > close of
      (fold mean_s = 0 then mean_s + open) / (fold mean_c = 0 then mean_c + 1);
\end{icicle}

Each query is converted to a query plan separately.
When we convert the @more@ query, we define the count inside a filter, and use it in the return section.

\begin{icicle-core}
plan stocks { open : Int; close : Int; }
folds { filter open > close {
    fold c    : Int = 0 then c + 1; } }
return { more : Int = c; }
\end{icicle-core}

We convert the @less@ and @mean@ queries similarly.
For the @mean@ query, the sum and the count are both defined inside a filter.
The division is performed in the @after@ section because it is an aggregate operation.

\begin{icicle-core}
plan stocks { open : Int; close : Int; }
folds { filter open < close {
    fold c    : Int = 0 then c + 1; } }
return { less : Int = c; }

plan stocks { open : Int; close : Int; }
folds { filter open > close {
    fold c    : Int = 0 then c + 1;
    fold s    : Int = 0 then s + open; } }
after  { sc   : Int = s / c }
return { mean : Int = sc; }
\end{icicle-core}

To fuse the three query plans together we freshen the names of each binding, then simply concatenate the corresponding parts of the anatomy.
The single-pass restriction on queries makes the fusion process so simple, because it ensures that there are no fusion-preventing dependencies between any two query plans. 
After concatenating the plans, we merge the filter blocks for @more@ and @mean@, as both use the same predicate.
When each query was expressed separately, we were free to transform each individual query without affecting the others.
Now the queries are interspersed but the stages are expressed separately, we are free to rearrange each stage without affecting the other stages.

\begin{icicle-core}
plan stocks { open : Int; close : Int; }
folds {
  filter open > close {
    fold more_c  : Int = 0 then more_c + 1;
    fold mean_c  : Int = 0 then mean_c + 1;
    fold mean_s  : Int = 0 then mean_s + open; }
  filter open < close {
    fold less_c  : Int = 0 then less_c + 1; } }
after  { mean_sc : Int = mean_s / mean_c }
return { more    : Int = more_c;
         less    : Int = less_c;
         mean    : Int = mean_sc; }
\end{icicle-core}

We can now use common subexpression elimination to remove the duplicate count, @mean_c@, as its binding is alpha-equivalent to the binding for @more_c@.
In the after section, the reference to @mean_c@ is replaced by @more_c@.

\begin{figure}
\begin{haskell}
queries :: IO (Push Record (Int,Int,Int))
queries = do
  more_c <- newIORef 0
  less_c <- newIORef 0
  mean_s <- newIORef 0
  mean_c <- newIORef 0

  let push record = do
    when (open record > close record) $ do
      modifyIORef more_c (+1)
    when (open record < close record) $ do
      modifyIORef less_c (+1)
    when (open record > close record) $ do
      modifyIORef mean_s (+ open record)
      modifyIORef mean_c (+1)

  let done = do
    more_c' <- readIORef more_c
    less_c' <- readIORef less_c
    mean_s' <- readIORef mean_s
    mean_c' <- readIORef mean_c
    return (more_c', less_c', div mean_s' mean_c')
        
  return (Push push done)
\end{haskell}
  \TODO{this is in @IO@, and has a different type from the earlier version. need to modify push representation to \Hs/Push a r = (IO (a -> IO (), IO r))/ so reference construction can be done as part of stream}
\caption{Push implementation of queries after inlining combinators}
\label{icicle:fig:core:push_query}
\end{figure}

To demonstrate the relative difficulty of removing the duplicate work in the general case, \autoref{icicle:fig:core:push_query} contains the push implementation of the same queries after inlining the definition of the combinators.
In this version, the @more_c@ and @mean_c@ references both hold the same value, but this fact is only evident with non-local reasoning about the program.
The reference initialisations and updates are located in different parts of the program, with potentially interfering writes in-between.
We could use a global value numbering~\citep{gulwani2004polynomial} algorithm to remove the duplicate work from the push implementation; such algorithms are generally polynomial time.
With the intermediate representation of Icicle we can use a common subexpression elimination algorithm~\cite{chitil1997common}, which requires $O(n \log n)$ time.

\subsection{A more complicated example}

The previous queries were simple to translate to the intermediate language; the query from \autoref{icicle:s:ElementsAndAggregates} is a bit more involved.
We first define the @mean@ and @last@ functions used in the query.
The @mean@ function then divides the @sum@ by the @count@.
\begin{icicle}
function mean (e : Element Int)
 = sum e / count;
\end{icicle}

The @last@ function uses a @fold@ that initialises the accumulator to the empty date value @NO_DATE@\footnote{In our production compiler, @last@ returns a @Maybe@.}, then updates it with the date gained from the current element in the stream.
\begin{icicle}
function last (d : Element Date)
 = fold l = NO_DATE then d;
\end{icicle}

% \begin{icicle}
%   query avg = let k    = last key in
%               let avgs = group key of mean value
%               in  lookup k avgs
% \end{icicle}


Inlining the above functions into the query from \autoref{icicle:s:ElementsAndAggregates} yields the following:
% This is guaranteed to terminate because no recursion is allowed in function definitions.
\begin{icicle}
query avg
 =    let lst = (fold l = NO_DATE then key)
   in let map = group key of
                ( (fold s = 0 then s + value)
                / (fold c = 0 then c + 1) )
   in let ret = lookup lst map
   in     ret
\end{icicle}

To convert this source query to a plan in the intermediate language we convert each of the let-bindings separately then concatenate the corresponding parts of the loop anatomy.
The @lst@ binding becomes a single fold, initialised to @NO_DATE@ and updated with the current @key@.
\begin{icicle-core}
plan kvs {      key : Date; value : Int;       }
folds    { fold fL  : Date = NO_DATE then key  }
after    {      lst : Date = fL                }
\end{icicle-core}

For the @map@ binding, each fold accumulator inside the body of the @group@ construct is nested within a @group@ in the intermediate language.
Inside the context of the @group@, the binding for @s@ refers to the @Int@ value for the current key; outside the @group@, in the @after@ section, @s@ refers to a value of (@Map Date Int@) containing the values of all keys.
Each time we receive a row from the table the accumulator associated with the @key@ is updated, using the default value @0@ if an entry for that key is not yet present.
After we have processed the entire table we join the maps and divide each sum by its corresponding count to yield a map of means for each key.
\begin{icicle-core}
folds  { group key
          { fold s : Int = 0 then s + value
          ; fold c : Int = 0 then c + 1 } }

after  { map : Map Date Int
          = mapMap (\sc. fst sc / snd sc) (mapZip s c) }
\end{icicle-core}

% It would be possible to convert this as a map of pairs of the sum and count.
% Keeping this as two separate maps rather than a map of pairs exposes more opportunities for common subexpression elimination when fusion occurs.
% For example, another query @group key of count@ can reuse the already constructed @gC@ map.

Finally, the @ret@ binding from the original query is evaluated in the @after@ stage. In the @return@ stage we specify that the result of the overall query @avg@ is the result of the @ret@ binding.
\begin{icicle-core}
  after  { ret : Int = lookup lst map }
  return { avg : Int = ret }
\end{icicle-core}


We then combine the plans from each binding.
This query plan is then fused with any other queries that process the same input; the fused query plan is then translated to an imperative loop nest in a similar way to prior work on flow fusion~\cite{lippmeier2013data}.
When translating folds nested inside @filter@s, the update statements are nested inside @if@ statements.
When translating folds nested inside @group@s, each accumulator becomes a map, and the update statements modify the element corresponding to the current key.
As with @filter@s, @group@s with the same key can be merged together.
The nested structure of @group@s allows us to share the same set of keys across multiple accumulators, further reducing duplicate work.

