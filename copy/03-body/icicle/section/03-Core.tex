%!TEX root = ../Main.tex
\section{Intermediate Language}
\label{icicle:s:IcicleCore}

The Icicle intermediate language is similar to a physical query plan for a database system.
We convert each source level query to a query plan, then fuse together the plans for queries on the same table.
Once we have the fused query plan we then perform standard optimisations such as common subexpression elimination and partial evaluation.

The grammar for the Icicle intermediate language is given in \autoref{icicle:fig:core:grammar}.
Expressions $PlanX$ include variables, values, applications of primitives and anonymous functions.
Function definitions and uses are not allowed in expressions here, as their definitions are inlined before converting to query plans.
Anonymous functions are only allowed as arguments to primitives: they cannot be applied or stored in variables.
The primitives of the source language are extended with key-value map primitives, which are used for implementing groups.
Folds are defined in $\mi{PlanF}$ and can be nested inside a filter, in which case the fold update is only performed when the predicate is true; the nested fold binding is available outside of the filter.
Folds nested inside a group are performed separately for each key; the nested fold binds a key-value map instead of a single value.
The $\mi{Plan}$ itself is split into a five stage \emph{loop anatomy}~\cite{shivers2005anatomy}.
First we have the name of the table and the names and element types of each column.
The @before@ stage then defines pure values which do not depend on any table data.
The @folds@ stage defines element computations and how they are converted to aggregate results.
The @after@ stage defines aggregate computations that combine multiple aggregations after the entire table has been processed.
Finally, the @return@ stage specifies the output values of the query; a single query will have only one output value, but the result of fusion can have many outputs.

\begin{figure}

\begin{tabbing}
MMM \= MM \= MMMM \= MMMM \= MMMMMM \= \kill
$\mi{PlanX}$
\GrammarDefTab
  $x~|~V~|~\mi{PlanP}~\ov{\mi{PlanX}}~|~\lam{x}\mi{PlanX}$
\\
$\mi{PlanP}$
\GrammarDefTab
  $\mi{Prim}~|~@mapUpdate@~|~@mapEmpty@~|~@mapMap@~|~@mapZip@$
\\
$\mi{PlanF}$
\GrammarDefTab
 $@fold@$ \> $~~x~:~T~=~\mi{PlanX}~@then@~\mi{PlanX};$
\GrammarAlt
 $@filter@$ \> $\mi{PlanX}$ \> $\{~\ov{\mi{PlanF}}~\}$
\GrammarAlt
  $@group@$ \> $\mi{PlanX}$ \> $\{~\ov{\mi{PlanF}}~\}$
\\
\\
$\mi{Plan}$
\GrammarDefTab
  $@plan@~x$ \> $\{~\ov{x~:~T;}~\}$
\\
  \> \> $@before@$ \> $\{~\ov{x~:~T~=~\mi{PlanX};}~\}$ \\
  \> \> $@folds@$  \> $\{~\ov{\mi{PlanF}}~\}$ \\
  \> \> $@after@$  \> $\{~\ov{x~:~T~=~\mi{PlanX};}~\}$ \\
  \> \> $@return@$ \> $\{~\ov{x~:~T~=~x;}~\}$ \\
\end{tabbing}



\caption{Query Plan Grammar}
\label{icicle:fig:core:grammar}
\end{figure}


Before we discuss an example query plan we first define the @count@ and @sum@ functions used in earlier sections.
Both functions are simple folds:
\begin{lstlisting}
function count
 = fold c = 0 then c + 1;

function sum (e : Element Int)
 = fold s = 0 then s + e;
\end{lstlisting}

Inlining these functions into the three queries from \hyperref[icicle:s:Introduction]{the start of the chapter} yields the following set of queries:

\begin{lstlisting}
table stocks { open : Int, close : Int }
query 
  more = filter open > close of fold more_c = 0 then more_c + 1;
  less = filter open < close of fold less_c = 0 then less_c + 1;
  mean = filter open > close of
      (fold mean_s = 0 then mean_s + open) / (fold mean_c = 0 then mean_c + 1);
\end{lstlisting}

Each query is converted to a query plan separately.
When we convert the @more@ query, we define the count inside a filter, and use it in the return section.

\begin{lstlisting}
plan stocks { open : Int; close : Int; }
folds { filter open > close {
    fold c    : Int = 0 then c + 1; } }
return { more : Int = c; }
\end{lstlisting}

We convert the @less@ and @mean@ queries similarly.
For the @mean@ query, the sum and the count are both defined inside a filter, and the division is performed after processing the entire input.

\begin{lstlisting}
plan stocks { open : Int; close : Int; }
folds { filter open < close {
    fold c    : Int = 0 then c + 1; } }
return { less : Int = c; }

plan stocks { open : Int; close : Int; }
folds { filter open > close {
    fold c    : Int = 0 then c + 1;
    fold s    : Int = 0 then s + open; } }
after  { sc   : Int = s / c }
return { mean : Int = sc; }
\end{lstlisting}

To fuse the three query plans together we freshen the names of each binding, then simply concatenate the corresponding parts of the anatomy.
The single-pass restriction on queries makes the fusion process so simple, because it ensures that there are no fusion-preventing dependencies between any two query plans. 
After concatenating the plans, we merge the filter blocks for @more@ and @mean@, as both use the same predicate.
When each query was expressed separately, we were free to transform each individual query without affecting the others.
Now the queries are interspersed but the stages are expressed separately, we are free to rearrange each stage without affecting the other stages.

\begin{lstlisting}
plan stocks { open : Int; close : Int; }
folds {
  filter open > close {
    fold more_c  : Int = 0 then more_c + 1;
    fold mean_c  : Int = 0 then mean_c + 1;
    fold mean_s  : Int = 0 then mean_s + open; }
  filter open < close {
    fold less_c  : Int = 0 then less_c + 1; } }
after  { mean_sc : Int = mean_s / mean_c }
return { more    : Int = more_c;
         less    : Int = less_c;
         mean    : Int = mean_sc; }
\end{lstlisting}

We can now use common subexpression elimination to remove the duplicate count, @mean_c@, as its binding is alpha-equivalent to the binding for @more_c@.
In the after section, the reference to @mean_c@ is replaced by @more_c@.

\begin{figure}
\begin{lstlisting}
queries :: IO (Push Record (Int,Int,Int))
queries = do
  more_c <- newIORef 0
  less_c <- newIORef 0
  mean_s <- newIORef 0
  mean_c <- newIORef 0

  let push record = do
    when (open record > close record) $ do
      modifyIORef more_c (+1)
    when (open record < close record) $ do
      modifyIORef less_c (+1)
    when (open record > close record) $ do
      modifyIORef mean_s (+ open record)
      modifyIORef mean_c (+1)

  let done = do
    more_c' <- readIORef more_c
    less_c' <- readIORef less_c
    mean_s' <- readIORef mean_s
    mean_c' <- readIORef mean_c
    return (more_c', less_c', div mean_s' mean_c')
        
  return (Push push done)
\end{lstlisting}
\caption{Compiled push queries}
\label{icicle:fig:core:push_query}
\end{figure}

In comparison, \autoref{icicle:fig:core:push_query} contains the push implementation of the same queries after inlining the definition of the combinators.
In this version, the @more_c@ and @mean_c@ references both hold the same value, but this is only evident with non-local reasoning about the program because the initialisation and update are in different places.
XX To remove the common subexpression, we need a non-local analysis such as global value numbering \citep{gulwani2004polynomial}.


Before we discuss an example query plan we first define the @count@, @sum@, @mean@ and @last@ functions used in earlier sections. Both @count@ and @sum@ are simple folds:
The @mean@ function then divides the @sum@ by the @count@.
\begin{lstlisting}
function mean (e : Element Real)
 = sum e / count;
\end{lstlisting}

The @last@ function uses a @fold@ that initializes the accumulator to the empty date value @NO_DATE@\footnote{In our production compiler, @last@ returns a @Maybe@.}, then updates it with the date gained from the current element in the stream.
\begin{lstlisting}
function last (d : Element Date)
 = fold l = NO_DATE then d;
\end{lstlisting}

% \begin{lstlisting}
%   query avg = let k    = last key in
%               let avgs = group key of mean value
%               in  lookup k avgs
% \end{lstlisting}


Inlining the above functions into the query from \autoref{icicle:s:ElementsAndAggregates} yields the following:
% This is guaranteed to terminate because no recursion is allowed in function definitions.
\begin{lstlisting}
query avg
 =    let lst = (fold l = NO_DATE then key)
   in let map = group key of
                ( (fold s = 0 then s + value)
                / (fold c = 0 then c + 1) )
   in let ret = lookup lst map
   in     ret
\end{lstlisting}

To convert this source query to a plan in the intermediate language we convert each of the let-bindings separately then simply concatenate the corresponding parts of the loop anatomy. The @lst@ binding becomes a single fold, initialized to @NO_DATE@ and updated with the current @key@.
\begin{lstlisting}
plan kvs {      key : Date; value : Real;      }
folds    { fold fL  : Date = NO_DATE then key  }
after    {      lst : Date = fL                }
\end{lstlisting}

For the @map@ binding, each fold accumulator inside the body of the @group@ construct is associated with its own finite map. The @s@ accumulator is associated with map @gS@, and the @c@ accumulator with @gC@. Each time we receive a row from the table the accumulator associated with the @key@ is updated, using the default value @0@ if an entry for that key is not yet present. After we have processed the entire table we divide each sum with its corresponding count to yield a map of means for each key.
\begin{lstlisting}
folds  { group key
          { fold gS : Real = 0 then gS + value
          ; fold gC : Real = 0 then gC + 1 } }

after  { map : Map Date Real
          = mapMap (\sc. fst sc / snd sc) (mapZip gS gC) }
\end{lstlisting}

% It would be possible to convert this as a map of pairs of the sum and count.
% Keeping this as two separate maps rather than a map of pairs exposes more opportunities for common subexpression elimination when fusion occurs.
% For example, another query @group key of count@ can reuse the already constructed @gC@ map.

Finally, the @ret@ binding from the original query is evaluated in the @after@ stage. In the @return@ stage we specify that the result of the overall query @avg@ is the result of the @ret@ binding.
\begin{lstlisting}
  after  { ret : Real = lookup lst map }
  return { avg : Real = ret }
\end{lstlisting}


XX To combine the plans from each binding we simply concatenate the corresponding parts of the anatomy.
To fuse multiple plans we freshen the names of each binding and also concatenate the corresponding parts of the anatomy.
The single-pass restriction on queries makes the fusion process so simple, because it ensures that there are no fusion-preventing dependencies between any two query plans. 

Given a fused query plan we then convert it to an imperative loop nest in a similar way to our prior work on flow fusion~\cite{lippmeier2013data}.

