%!TEX root = ../Main.tex
\section{Related work}
\label{icicle:s:Conclusion}

% This paper has introduced Icicle, a streaming query language. The streaming, single-pass nature of Icicle allows all queries over the same table to be fused into a single loop over the data.
% Icicle's modal type system allows incremental computation, ensuring that queries give the same value regardless of how the input is sliced up, and when the increments are performed.
% The modal types encode when computations are available, and disallows using the results of folds before they are finished.
% \ben{the above paragraph doesn't add any new information}.

In Icicle, as in the push streams from \cref{taxonomy/push}, there is only one input stream, sourced from the input table, which is implicit in the bodies of queries.
This approach is intentionally simpler than existing synchronous data flow languages such as Lucy~\cite{mandel2010lucy} and fusion techniques using synchronous data flow such as flow fusion~\cite{lippmeier2013data}.
Synchronous data flow languages implement Kahn networks~\cite{vrba2009kahn} that are restricted to use bounded buffering~\cite{johnston2004advances} by clock typing and causal analysis~\cite{stephens1997survey}.
In such languages, stream combinators with multiple inputs, such as @zip@, are assigned types that require their stream arguments to have the same clock --- meaning that elements always arrive in lockstep and the combinators themselves do not need to perform their own buffering.
In Icicle the fact that the input stream is implicit and distributed to all combinators means that we can forgo clock analysis.
All queries in a program execute in lock-step on the same element at the same moment, which ensures that fusion is a simple matter of concatenating the components of the loop anatomy of each query.

\begin{lucy}[float,caption=Lucid-Synchrone implementation of stocks queries,label=icicle:fig:related:lucy:stocks]
type table = { open_price : int; close_price : int }

let node more input =
 let clock gt = (input.open_price > input.close_price)
 in let c = count (() when gt)
 in hold 0 gt c

let node less input =
 let clock lt = (input.open_price < input.close_price)
 in let c = count (() when lt)
 in hold 0 lt c

let node mean input =
 let clock gt = (input.open_price > input.close_price)
 in let s = sum (input.open_price when gt)
 in let c = count (() when gt)
 in let m = div s c
 in hold 0 gt m
\end{lucy}

\Cref{icicle:fig:related:lucy:stocks} shows the three \Lucy/stocks/ example queries implemented in the synchronous data flow language Lucid Synchrone.
The \Lucy/more/ query counts the number of elements where the open price is greater than the close price by defining a new clock \Lucy/gt/.
The \Lucy/c/ binding counts the number of elements that satisfy the predicate by restricting the unit argument of the \Lucy/count/ function to the clock \Lucy/gt/, using the syntax \Lucy/(() when gt)/.
As the argument to \Lucy/count/ is restricted to the clock \Lucy/gt/, the count will only increment when the clock is true.
If we had instead restricted the result of \Lucy/count/ using the syntax \Lucy/((count ()) when gt)/, the count would be incremented for each input element, but the result would only be sampled when the predicate was true.
The \Lucy/c/ binding is only defined when the predicate is true; the \Lucy/hold/ function returns a stream that is always defined, by sampling the most recent value of \Lucy/c/, or using the default value \Lucy/0/ if no value of \Lucy/c/ is available.

Lucid Synchrone does not eliminate the common subexpressions in this example; subexpressions in Lucid Synchrone can perform effects and removing them may change the semantics of the program.
TODO: however, the above version of the \Lucy/mean/ query performs the division on every iteration. For more complex queries, performing the eject function on every iteration could be a significant amount of work.
To solve this, we can encode another clock denoting when to perform the ejection, as follows:

\begin{lucy}
let node mean input eject =
 let clock gt = (input.popen > input.pclose)
 in let s = sum (input.popen when gt)
 in let c = count (() when gt)
 in let s' = hold 0 gt s
 in let c' = hold 0 gt c
 in let m = div (s' when eject) (c' when eject)
 in m
\end{lucy}

TODO: talk about the code generation and compare to Icicle.


Shortcut fusion techniques such as foldr/build~\cite{gill1993short} and stream fusion~\cite{coutts2007stream} rely on inlining to expose fusion opportunities.
In Haskell compilers such as GHC, the decision of when to inline is made by internal compiler heuristics, which makes it difficult for the programmer to predict when fusion will occur.
When shortcut fusion cannot fuse a program, it fails silently, leaving the programmer unaware of the failure.
In this environment, array fusion is considered a ``bonus'' optimisation rather than integral part of the compilation method.
In contrast, for our feature generation application we really must ensure that multiple queries over the same table are fused, so we cannot rely on heuristics.

StreamIt~\cite{thies2002streamit} is an imperative streaming language which has been extended with dynamic scheduling~\cite{soule2013dynamic}.
Dynamic scheduling handles data flow graphs where the transfer rate between different stream operators is not known at compile time.
Dynamic scheduling is a trade-off: it is required for stream operators such as grouping and filtering where the output data rate is not known statically, but using dynamic techniques for graphs with static transfer rates tends to have a performance cost.
Icicle includes grouping and filtering operators where the output rates are statically unknown, however the associated language constructs require grouped and filtered data to be aggregated rather than passed as the input to another stream operator.
This allows Icicle to retain fully static scheduling, so the compiled queries consist of straight line code with no buffering.

Icicle is closely related to work in continuous and shared queries.
A continuous query is one that processes input data which may have new records added or removed from it at any time.
The result of the continuous query must be updated as soon as the input data changes.
Shared queries are ones in which the same sub expressions occur in several individual queries over the same data, and we wish to share the results of these sub expressions among all individuals that use them.
For example, in \citet{munagala2007optimization}, input records are filtered by a conjunction of predicates, and the predicates occur in multiple queries.
\citet{madden2002continuously} uses a predicate index to avoid recomputing them.
\citet{andrade2003efficient} describes a compiler for queries over geospacial imagery that shares the results of several pre-defined aggregation functions between queries.
Continuous Query Language (CQL)~\cite{arasu2002abstract,stream2003stream} again allows aggregates in its queries, but they must be builtin aggregate functions.
Icicle addresses a computationally similar problem, except that our input data sets can only have new records added rather than deleted, which allows us to support general aggregations rather than just filter predicates.
It is not obvious how arbitrary aggregate functions could be supported while also allowing deletion of records from the input data --- other than by recomputing the entire aggregation after each deletion.


% How to architect a query compiler~\cite{shaikhha2016architect}.
% Scheduling dynamic dataflow~\cite{buck1993scheduling}.
% Co-iterative characterization~\cite{caspi1998co}.
